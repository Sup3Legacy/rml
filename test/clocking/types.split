$$$good
${
(*
  run_test:
   [
     Good: "../../compiler/rpmlc.byte -no-reactivity -I ../../lib/ -c"
   ]
*)

$}

type r = { x : float; y : float }

let f x y =
  { x = x; y = y }

$

type 'a siglist{'ck|} = ('a, 'a) event{'ck|} list

$

type siglist{'ck|} = (int, int) event{'ck|} list

$

type actor{|''f} = unit =>{''f} unit

$

type intproc{'ck|''f} = int process{'ck|''f}

$

type intproc{'ck|} = int process{'ck|'ck}

$

type intproc{|''f} = int process{topck|''f + topck}

$

type 'a siglist{'ck|} = { s_list : ('a, 'a) event{'ck|} list }


let process f ck =
  signal s at ck default 0 gather (+) in
  { s_list = [s] }


$

type witheff = { f: int => int }

let process p =
  signal s default 0 gather (+) in
  { f = (fun i -> emit s i; 0) }, { f = (fun x -> x) }


$

type witheff = { f: witheff => int }

$

type t1 = { f: t2 => int }
and t2 = t1 process

$

type witheff = { f: witheff => int }

type t = { l1 : witheff; l2 : witheff }

$

let rec iter f l = match l with
  | [] -> ()
  | x::l -> (f x); (iter f l)


let p l =
  iter (fun s -> emit s) l

$

let process f ck (s: (int,int)event{ck|}) =
  pause; emit s 0

let process g =
  signal s at topck default 0 gather (+) in
  f topck s

$$$bad
${
(*
  run_test:
   [
     Bad 2 "": "../../compiler/rpmlc.byte -no-reactivity -I ../../lib/ -c"
   ]
*)

$}

type noeff = { f: int -> int }

let process p =
  signal s default 0 gather (+) in
  { f = (fun i -> emit s i; 0) }


$$$ident_unbound
${
(*
  run_test:
   [
     Bad 2 "unbound": "../../compiler/rpmlc.byte -no-reactivity -I ../../lib/ -c"
   ]
*)
$}

let process p (s:(int, int)event{ck}) =
  pause; emit s 0