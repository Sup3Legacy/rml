let random_int min max =
  min + Random.int (max - min)

let random_float min max =
  min +. Random.float (max -. min)

let process sustain n s v =
  for i = 1 to n do
    emit s(v);
    pause
  done

(* Vector operations*)
type vector = { v_x : float; v_y : float; v_z : float }

let mk_vector x y z =
  { v_x = x; v_y = y; v_z = z }

let zero_vector = { v_x = 0.0; v_y = 0.0; v_z = 0.0 }

let random_vector xmin ymin xmax ymax =
  { v_x = random_float xmin xmax;
    v_y = random_float ymin ymax;
    v_z = 0.0; }

let norm2 v =
  v.v_x *. v.v_x +. v.v_y *. v.v_y +. v.v_z *. v.v_z

let dist2 v1 v2 =
  (v2.v_x -. v1.v_x) *. (v2.v_x -. v1.v_x)
    +. (v2.v_y -. v1.v_y) *. (v2.v_y -. v1.v_y)
    +. (v2.v_z -. v1.v_z) *. (v2.v_z -. v1.v_z)

let unit_vector v1 v2 =
  let d2 = dist2 v1 v2 in
  let d = sqrt d2 in
  { v_x = (v2.v_x -. v1.v_x) /. d;
    v_y = (v2.v_y -. v1.v_y) /. d;
    v_z = (v2.v_z -. v1.v_z) /. d }

let normal_unit_vector v1 v2 =
  let d2 = dist2 v1 v2 in
  let d = sqrt d2 in
  { v_x = -. (v2.v_y -. v1.v_y) /. d;
    v_y = (v2.v_x -. v1.v_x) /. d;
    v_z = (v2.v_z -. v1.v_z) /. d }

let (++.) v1 v2 =
  { v_x = v1.v_x +. v2.v_x;
    v_y = v1.v_y +. v2.v_y;
    v_z = v1.v_z +. v2.v_z }

let ( **. ) a v =
  { v_x = a *. v.v_x; v_y = a *. v.v_y; v_z = a *. v.v_z;  }

let vector_error v1 v2 =
  (dist2 v1 v2) /. (norm2 v1)

(* Data structures *)

let gen_id =
  let counter = ref 0 in
  fun () ->
    incr counter;
    !counter

type body =
    { b_id : int;
      mutable b_pos : (vector, vector) event;
      mutable b_vel : vector;
      b_weight : float; }

let process mk_body ck pos v weight =
  signal pos at ck default pos gather (fun v _ -> v) in
  { b_id = gen_id ();
    b_pos = pos;
    b_vel = v;
    b_weight = weight;
  }

(* Computing forces *)
let g = 3.0

let force (pos2, w2) pos1 =
  let d2 = dist2 pos1 pos2 in
  if (d2 <> 0.0) then
    let f12 = (g *. w2) /. d2 in
    (*print_float f12; print_newline (); *)
    f12 **. (unit_vector pos1 pos2)
  else
    zero_vector

let rec process wait n =
  if n > 0 then
    (pause; run wait (n-1))

let compute_force st all =
  let me = last st.b_pos in
  List.fold_left (fun acc b -> force b me ++. acc) zero_vector all

let compute_mass_center all =
  let p = List.fold_left (fun acc (x_t, w) -> acc ++. (w **. x_t)) zero_vector all in
  let w_sum = List.fold_left (fun acc (_, w) -> acc +. w) 0.0 all in
  (1. /. w_sum) **. p, w_sum

let compute_move (new_p, _) (old_p, _) =
  new_p ++. (-1.0 **. old_p)

let compute_euler_semi_implicit dt x_t v_t w a_t =
  let v_tp = v_t ++. (dt **. a_t) in
  let x_tp = x_t ++. (dt **. v_tp) in
  (x_tp, v_tp)

let random_pos_planet c_x c_y dmin dmax =
  let rand_away z d =
    if Random.bool () then z +. d else z -. d
  in
  let d = random_float dmin dmax in
  let x = random_float (c_x -. d) (c_x +. d) in
  let dy = sqrt ( (d *. d) -. ((x -. c_x) *. (x -. c_x)) ) in
  let y = rand_away c_y dy in
  mk_vector x y 0.0

let process body st dt env =
  emit env (last st.b_pos, st.b_weight);
  loop
    await env(all) in
    let f = compute_force st all in
    let x_tp, v_tp = compute_euler_semi_implicit dt (last st.b_pos) st.b_vel st.b_weight f in
    emit st.b_pos x_tp;
    st.b_vel <- v_tp;
    emit env (x_tp, st.b_weight);
  end

let process composed_body local_steps center dt env pck p mass_center =
  domain(local_ck) do
    signal local_env in
    loop
      await env(all) in
      let all = List.filter ((fun (x_m, _) (x_j, _) -> x_j <> x_m) !!mass_center) all in
      List.iter (fun p -> emit local_env p) all;
      for i=1 to local_steps-1 do
        pause local_ck; List.iter (fun p -> emit local_env p) all
      done
    end
    ||
    emit env center;
    pause pck;
    loop
      run wait (local_steps - 1);
      let local_planets =
        List.filter
          (fun (p, _) -> List.for_all (fun (p2, _) -> p <> p2) (last env))
          (last local_env)
      in
      let new_center = compute_mass_center local_planets in
      mass_center ::= new_center;
      emit env new_center;
      pause pck
    end
    ||
    pause pck; run p local_ck (dt /. (float_of_int local_steps)) local_env
  by local_steps done

let nb_planets = 500
let nb_systems = 4
let nb_local_steps = 100

let planet_mass = 0.00001
let sun_mass = 1.0
let black_hole_mass = 8000.0

let process planet ck center v_0 (x_0, w) dt env =
  let st = run mk_body ck x_0
      (v_0 ++. (1.0 **. (normal_unit_vector x_0 center)))
      w
  in
  run (body st dt env)

let process sun ck center v_0 dt env =
  let st = run mk_body ck center v_0 sun_mass in
  run (body st dt env)

(*
let process solar_system_point center vp dt env =
  let system_center = random_pos_planet center.v_x center.v_y 20000.0 40000.0 in
  let planets = Array.init nb_planets
      (fun _ -> random_pos_planet system_center.v_x system_center.v_y 10.0 20.0, planet_mass) in
  let center_mass = compute_mass_center ((system_center, sun_mass)::(Array.to_list planets)) in
  let v_0 = 1.0 **. (normal_unit_vector system_center center) in
  let process p ck dt env =
    for i = 0 to nb_planets-1 dopar
      run planet ck system_center v_0 planets.(i) vp dt env
    done
    ||
    run sun ck system_center v_0 vp dt env
  in
  memory mass_center last center_mass in
  run composed_body 10 center_mass dt env topck p mass_center
  ||
  let sp = Mlsdl_client.create_sprite_from_file vp null_float_pos 48 48 "sun.png" in
  run solar_system_sprite mass_center sp
*)

let process solar_system_viewport center dt env =
  let system_center = random_pos_planet center.v_x center.v_y 20000.0 40000.0 in
  let planets = Array.init nb_planets
      (fun _ -> random_pos_planet system_center.v_x system_center.v_y 1.0 3.0, planet_mass) in
  let center_mass = compute_mass_center ((system_center, sun_mass)::(Array.to_list planets)) in
  let v_0 = 10.0 **. (normal_unit_vector system_center center) in
  let process p ck dt env =
    for i = 0 to nb_planets-1 dopar
      run planet ck system_center v_0 planets.(i) dt env
    done
    ||
    run sun ck system_center v_0 dt env
  in
  memory mass_center last center_mass in
  run composed_body nb_local_steps center_mass dt env topck p mass_center

let process black_hole pos dt env =
  let st = run mk_body topck pos zero_vector black_hole_mass in
  run (body st dt env)

let _ = Random.self_init ()

let process main =
  let center = mk_vector 10000.0 10000.0 0.0 in
  let dt = 0.1 in
  signal env in
  for i=1 to nb_systems dopar
    run solar_system_viewport center dt env
  done
  ||
  run black_hole center dt env
