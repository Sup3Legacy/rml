(****************************************************)
(** Adaptative version ******************************)
(****************************************************)
(****************************************************)

let random_int min max =
  min + Random.int (max - min)

let random_float min max =
  min +. Random.float (max -. min)

let process sustain n s v =
  for i = 1 to n do
    emit s(v);
    pause
  done

(* Vector operations*)
type vector = { v_x : float; v_y : float; v_z : float }

let mk_vector x y z =
  { v_x = x; v_y = y; v_z = z }

let zero_vector = { v_x = 0.0; v_y = 0.0; v_z = 0.0 }

let random_vector xmin ymin xmax ymax =
  { v_x = random_float xmin xmax;
    v_y = random_float ymin ymax;
    v_z = 0.0; }

let norm2 v =
  v.v_x *. v.v_x +. v.v_y *. v.v_y +. v.v_z *. v.v_z

let dist2 v1 v2 =
  (v2.v_x -. v1.v_x) *. (v2.v_x -. v1.v_x)
    +. (v2.v_y -. v1.v_y) *. (v2.v_y -. v1.v_y)
    +. (v2.v_z -. v1.v_z) *. (v2.v_z -. v1.v_z)

let unit_vector v1 v2 =
  let d2 = dist2 v1 v2 in
  let d = sqrt d2 in
  { v_x = (v2.v_x -. v1.v_x) /. d;
    v_y = (v2.v_y -. v1.v_y) /. d;
    v_z = (v2.v_z -. v1.v_z) /. d }

let normal_unit_vector v1 v2 =
  let d2 = dist2 v1 v2 in
  let d = sqrt d2 in
  { v_x = -. (v2.v_y -. v1.v_y) /. d;
    v_y = (v2.v_x -. v1.v_x) /. d;
    v_z = (v2.v_z -. v1.v_z) /. d }

let add_vector v1 v2 =
  { v_x = v1.v_x +. v2.v_x;
    v_y = v1.v_y +. v2.v_y;
    v_z = v1.v_z +. v2.v_z }

let scalar_mult a v =
  { v_x = a *. v.v_x; v_y = a *. v.v_y; v_z = a *. v.v_z;  }

let vector_error v1 v2 =
  (dist2 v1 v2) /. (norm2 v1)

(* Data structures *)

let gen_id =
  let counter = ref 0 in
  fun () ->
    incr counter;
    !counter

type body =
    { b_id : int;
      mutable b_pos : (vector, vector) event;
      mutable b_vel : vector;
      b_weight : float; }

let mk_body ck pos v weight =
  signal pos at ck default pos gather (fun v _ -> v) in
  { b_id = gen_id ();
    b_pos = pos;
    b_vel = v;
    b_weight = weight;
  }

(* Computing forces *)
let g = 3.0

let force (pos2, w2) pos1 =
  let d2 = dist2 pos1 pos2 in
  if (d2 <> 0.0) then
    let f12 = (g *. w2) /. d2 in
    (*print_float f12; print_newline (); *)
    scalar_mult f12 (unit_vector pos1 pos2)
  else
    zero_vector

let process env_signal =
  let add_force f_new f =
    fun (pos: vector) ->
      add_vector (f_new pos) (f pos)
  in
  signal env default (fun _ -> zero_vector) gather add_force in
  env

(**This is semi implicit Euler method *)
(*let compute_pos dt st all =
  let add_force f body = add_vector (force st.b_pos body) f in
  let f = List.fold_left add_force zero_vector all in
  st.b_vel <- add_vector st.b_vel (scalar_mult dt f);
  st.b_pos <- add_vector st.b_pos (scalar_mult dt st.b_vel)
*)

(* various functions to create examples *)
let random_pos_planet c_x c_y dmin dmax =
  let rand_away z d =
    if Random.bool () then z +. d else z -. d
  in
  let d = random_float dmin dmax in
  let x = random_float (c_x -. d) (c_x +. d) in
  let dy = sqrt ( (d *. d) -. ((x -. c_x) *. (x -. c_x)) ) in
  let y = rand_away c_y dy in
  mk_vector x y 0.0


let adaptive_fuel = 0

let process no_compute env x_t v_t w =
  (x_t, v_t, 0.0)

let process compute_a env x w =
  emit env (force (x, w));
  await env(f) in
  f x


let process compute_bogacki_shampine dt env x_t v_t w =
  (* step 1 *)
  let k1_v = run (compute_a env x_t w) in
  let k1_p = v_t in
  (* step 2 *)
  let k2_p = add_vector v_t (scalar_mult (dt /. 2.0) k1_v) in
  let x_2 = add_vector x_t (scalar_mult (dt /. 2.0) k1_p) in
  let k2_v = run (compute_a env x_2 w) in
  (* step 3 *)
  let k3_p = add_vector v_t (scalar_mult (0.75 *. dt) k2_v) in
  let x_3 = add_vector x_t (scalar_mult (0.75 *. dt) k2_p) in
  let k3_v = run (compute_a env x_3 w) in
  (* final result *)
  let v_tp =
    add_vector v_t (scalar_mult (dt /. 9.0)
                      (add_vector (scalar_mult 2.0 k1_v)
                         (add_vector (scalar_mult 3.0 k2_v)
                            (scalar_mult 4.0 k3_v))) )
  in
  let x_tp =
    add_vector x_t (scalar_mult (dt /. 9.0)
                      (add_vector (scalar_mult 2.0 k1_p)
                         (add_vector (scalar_mult 3.0 k2_p)
                            (scalar_mult 4.0 k3_p))) )
  in
  (*error computation*)
  (* step 3 *)
  let k4_v = run (compute_a env x_tp w) in
  (* second final value *)
  let v_s =
    add_vector v_t (scalar_mult (dt /. 24.0)
                      (add_vector (scalar_mult 7.0 k1_v)
                         (add_vector (scalar_mult 6.0 k2_v)
                            (add_vector (scalar_mult 8.0 k3_v)
                               (scalar_mult 3.0 k4_v)))))
  in
  let e = vector_error v_tp v_s in
  (*print_float e; print_newline ();*)
  x_tp, v_tp, e

let process body st compute env error adapt_ck =
  let rec process do_compute f =
    do
      let x_tp, v_tp, e = run (f env (pre? st.b_pos) st.b_vel st.b_weight) in
      emit error(e);
      pause adapt_ck;
      (*wait for possible preemption here*)
      pause adapt_ck;
      (*step is ok; write back result*)
      emit st.b_pos x_tp;
      st.b_vel <- v_tp
    until compute(f) -> run (do_compute f) done
  in
  loop
    await compute(f) in
    run (do_compute f)
  end

let process container time_step error_threshold p pck =
  newclock adapt_ck in
    signal error default 0.0 gather max in
    signal compute default no_compute gather (fun x _ -> x) in
    let rec process try_step fuel s =
      emit compute(compute_bogacki_shampine s);
      await error(e) in
      if e > error_threshold && fuel > 0 then (
        (*print_string "Error found; trying with step : "; print_float (s /. 2.0); print_newline ();*)
        run (try_step (fuel - 1) (s /. 2.0));
        run (try_step (fuel - 1) (s /. 2.0))
      ) else (
        pause
      )
    in
    loop
      run (try_step adaptive_fuel time_step);
      pause pck
    end
    ||
    newclock computation_ck in
      let env = run env_signal in
      run (p compute env error adapt_ck)


let process planet center compute env error adapt_ck =
  let pos = random_pos_planet center.v_x center.v_y 200.0 350.0 in
  let st = mk_body topck pos
      (scalar_mult 10.0 (normal_unit_vector pos center))
      (random_float 0.01 0.01)
  in
  run (body st compute env error adapt_ck)

let process sun center compute env error adapt_ck =
  let st = mk_body topck center zero_vector 8000.0 in
  run (body st compute env error adapt_ck)

let w = 1000
let h = 800
let nb_procs = 8
let nb_planets_per_procs = 10

let _ = Random.self_init ()

let process main =
  let center = mk_vector 1000.0 1000.0 0.0 in
  let process p compute env error adapt_ck =
    run (sun center compute env error adapt_ck)
    ||
    pause;
    for i = 1 to nb_procs dopar
      newclock ck in (
        for i = 1 to nb_planets_per_procs dopar
          run (planet center compute env error adapt_ck)
        done
      )
    done
  in
  run (container 1.0 1e-6 p topck)
