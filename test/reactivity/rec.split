$$$good
${
(*
  run_test:
   [
    Good: "../../compiler/rpmlc.byte -I ../../lib/ -c -dwarn_error"
   ]
*)

$}

let rec process p =
   print_endline "Coucou"; pause; run p

$

let rec process p q =
  let x = run q in
  let z = run p q in
  run q

$$$bad
${
(*
  run_test:
   [
    Bad 2 "instantaneous": "../../compiler/rpmlc.byte -I ../../lib/ -c -dwarn_error"
   ]
*)

$}

let rec process p = run p

$

let rec process p = print_endline "Coucou"; run p

$

let process do_one = pause; pause; print_endline "Coucou"

let rec process p n =
  if n > 0 then
    (run do_one || run p (n-1))

$

let rec process p =
  let q = p in
  run q

$

let rec process p =
  let rec process q =
    run p; pause; run q
  in
  run q

$

let rec process p =
 let r = ref (process ()) in
 r := p;
 run !r

$

let f x = x

let rec process p =
  let q = f p in
  run q

$

let rec process p =
  let q = (fun x -> x) p in
  run q

$

let test f =
 let rec process p =
   let q = f p in
   run q
 in
 p

let process pb = run (test (fun x -> x))

$

let rec process y =
  let p =
    let x =
      (process y)
    in
    run x
  in
  run p

$

let landin q =
 let f = ref q in
 f := process (run q; run !f);
 run !f

$

let rec process p s =
  present s then () else ();
  run (p s)

$

let rec process p =
  signal s in
  emit s p;
  await immediate one s(x) in
  run x

$

let rec f _ =
  (fun x -> process (run (f ()))) 0

$

let rec fix f x = f (fix f) x

let process main =
  let process f p v =
    print_endline "xxx"; run (p v)
  in
  run (fix f ())

$

type 'a recc = In of ('a recc -> 'a)
let out (In x) = x

let y f = (fun x a -> f (out x x) a) (In (fun x a -> f (out x x) a))

let f =
 (fun p -> fun v -> process (print_endline "coucou"; run (p v)))

let process main_y = run (y f ())

$

let rec process p f =
 run f;
 if false then run (p (process (pause)))
 else run (p (process ()))

$

let rec process p f =
 run f;
 if false then run (p (process ()))
 else run (p (process (pause)))

$

let rec process map p l = match l with
| [] -> []
| x::l ->
    let y = run (p l)
    and l = run (map p l) in
    y::l

let process main = run (fun _ -> process ())

$

let rec process p q =
 ignore (q = process (pause));
 run q;
 run (p q)

let process p_unit =
 run (p (process ()))

$

let landin () =
 let f = ref (process ()) in
 f := process (print_endline "landin"; run !f);
 !f