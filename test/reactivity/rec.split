$$$good
${
(*
  run_test:
   [
    Good: "../../compiler/rpmlc.byte -I ../../lib/ -c -dwarn_error"
   ]
*)

$}

let rec process p =
   print_endline "Coucou"; pause; run p

$$$bad
${
(*
  run_test:
   [
    Bad 2 "instantaneous": "../../compiler/rpmlc.byte -I ../../lib/ -c -dwarn_error"
   ]
*)

$}

let rec process p = run p

$

let rec process p = print_endline "Coucou"; run p

$

let process do_one = pause; pause; print_endline "Coucou"

let rec process p n =
  if n > 0 then
    (run do_one || run p (n-1))

$

let rec process p =
  let q = p in
  run q

$

let rec process p =
  let rec process q =
    run p; pause; run q
  in
  run q

$

let rec process p =
 let r = ref (process ()) in
 r := p;
 run !r

$

let f x = x

let rec process p =
  let q = f p in
  run q

$

let rec process p =
  let q = (fun x -> x) p in
  run q

$

let test f =
 let rec process p =
   let q = f p in
   run q
 in
 p

let process pb = run (test (fun x -> x))

$

let rec process y =
  let p =
    let x =
      (process y)
    in
    run x
  in
  run p

$

let landin q =
 let f = ref q in
 f := process (run q; run !f);
 run !f

$

let rec process p s =
  present s then () else ();
  run (p s)

$

let rec process p =
  signal s in
  emit s p;
  await immediate one s(x) in
  run x

$

let rec f _ =
  (fun x -> process (run (f ()))) 0

$

let rec fix f x = f (fix f) x

let process main =
  let f =
    (fun p -> fun v -> process (print_endline "xxx"; run (p v)))
  in
  run (fix f ())

$

let rec process p f =
 run f;
 if false then run (p (process (pause)))
 else run (p (process ()))

$

let rec process p f =
 run f;
 if false then run (p (process ()))
 else run (p (process (pause)))

$

let landin () =
 let f = ref (process ()) in
 f := process (print_endline "landin"; run !f);
 !f