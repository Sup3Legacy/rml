let process f =
  newclock ck in
  signal ss in
  signal s2 at base in
  signal sss default 0 gather (+) in
  signal s at ck in
  signal s3 at topck in
  signal s2 at topck default 0 gather (+) in
  signal s2 at ck default 0 gather (+) in
    emit s

let process g =
  newclock ck in
  signal ss in
  signal sss default 0 gather (+) in
  signal s at ck in
  signal s3 at topck in
  signal s2 at topck default 0 gather (+) in
  signal s2 at ck default 0 gather (+) in
    pause; emit s

(* [N; O 3] *)
let process sigat act =
  newclock ck in
  signal s at topck default 0 gather (+) in
    loop
      pause; pause topck
    end
    ||
    emit s 3
    ||
    await s(v) in act v

(* [O 1; O 3] *)
let process sigat_remote act =
  newclock ck in
    act 1
  ||
  newclock ck2 in
    signal s at topck default 0 gather (+) in
    emit s 3;
    pause topck;
    act (pre? s)

let process sigat_restrict act =
  newclock ck in
    signal s at topck restrict ck default 0 gather (+) in
    emit s 3;
    pause topck;
    act (pre? s)

open Rmltest

let test =
 [
   (sigat, "sigat", [N; O 3]);
   (sigat_remote, "sigat_remote", [O 1; O 3]);
   (sigat_restrict, "sigat_restrict", [N; O 3])
 ]
