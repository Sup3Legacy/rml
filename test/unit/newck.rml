(* minimalistic newclock *)
(*[O 0]*)
let process ck_one_step act =
  newclock ck in
    pause ck; act 0

(* end of macro step with pauseclock *)
(* let ck = S (O 0, S (O 1, O 2)) in  [ck; ck] *)
let process ck_macro_pauseck act =
  (newclock ck in
    loop
      act 0; pause; act 1; pause; act 2; pauseclock ck
    end)

(* end of macro step with pause on topck *)
(* let ck = S (O 0, S (O 1, O 2)) in  [ck; ck] *)
let process ck_macro_pause_topck act =
  (newclock ck in
    loop
      act 0; pause; act 1; pause; act 2; pause topck
    end)

(* end of macro step with await on slow signal*)
(* [N; N; O 5] *)
let process ck_macro_await_slow act =
  signal s default 0 gather (+) in
  pause; emit s 0
  ||
  newclock ck in
    await s(0) in act 5

(* let ck = S (O 0, S (O 1, O 2)) in  [P [ck; O 8]; P [ck; O 7]] *)
let process ck_macro_pauseck_par act =
  (newclock ck in
    loop
      act 0; pause; act 1; pause; act 2; pauseclock ck
    end)
  ||
  loop
    act 8; pause; act 7; pause
  end

(* let ck = S (O 0, S (O 1, O 2)) in [ck; ck; P[ck; O 5]] *)
let process ck_macro_multi act =
  signal s default 0 gather (+) in
  pause; emit s 0
  ||
  newclock ck in
   ((await s(0) in act 5)
   ||
   loop
     act 0; pause; act 1; pause; act 2; pause topck
   end)

(* [N; O 3] *)
let process ck_macro_nested act =
  signal s default 0 gather (+) in
  emit s 3
  ||
  newclock ck1 in (
    newclock ck2 in
      await s(v) in act v
  )

(* S (O 0, S (O 1, O 2)) *)
let process ck_done act =
  (newclock ck in
    act 0; pause; act 1);
  act 2

(* [ S(P [O 1; O 3], P [O 2; O 4]) ] *)
let process nested_clocks act =
  newclock ck1 in (
    (newclock ck2 in
      loop
        act 1; pause ck1; act 2; pause topck
      end)
    ||
    act 3; pause ck1; act 4
 )

(* [ S(O 1, O 2) ] *)
let process nested_clocks_direct act =
  newclock ck1 in (
    (newclock ck2 in
      loop
        act 1; pause ck1; act 2; pause topck
      end)
  )


(* [ S(O 1, O 2) ] *)
let process nested_clocks_direct2 act =
  newclock ck1 in (
    (newclock ck3 in
       pause topck; pause topck)
    ||
    (newclock ck2 in
      loop
        act 1; pause ck1; act 2; pause topck
      end)
  )

(* [ S(O 1, O 2) ] *)
let process nested_clocks_direct3 act =
 newclock c in (
  newclock ck1 in (
    (newclock ck3 in
       pause topck; pause topck)
    ||
    (newclock ck2 in
      loop
        act 1; pause c; act 2; pause topck
      end)
  )
 )

(* [O 2; O 3; N; O 4] *)
let process macro_instant act =
  signal s default 0 gather (+) in
  newclock ck in (
    signal s2 at ck default 0 gather (+) in
    newclock ck2 in (
      (await s(v) in act v)
      ||
      (await s2(v) in act v)
      ||
      pause ck; act 2; pause topck; emit s2 3; pause topck; emit s 4
    )
  )

(* [O 2; O 3; O 2; P[O 3; O 4]; O 2; P[O 3; O 4]] *)
let process macro_instant_loop act =
  signal s default 0 gather (+) in
  newclock ck in (
    signal s2 at ck default 0 gather (+) in
    newclock ck2 in (
      loop
        await s(v) in act v
      end
      ||
      loop
        await s2(v) in act v
      end
      ||
      loop
        pause ck; act 2; pause topck; emit s2 3; pause topck; emit s 4
      end
    )
  )

(* let v = P[O 4; O 5; O 6; O 7] in
  [N; v; v; N; v; v] *)
let process await_slow_loop act =
 newclock adapt_ck in (
  signal s default 0 gather (+) in
  loop
    pause topck;
    emit s 3;
    pause topck;
    emit s 3;
    pause topck;
  end
  ||
  (
  pause topck;
  newclock computation_ck in (
    for i = 1 to 4 dopar
      newclock ck2 in
        loop
          await s(v) in act (v+i)
        end
    done
  )
  )
 )

open Rmltest

let test =
  let ck = S (O 0, S (O 1, O 2)) in
  let v = P[O 4; O 5; O 6; O 7] in
   [ (ck_one_step, "ck_one_step", [O 0]);
     (ck_macro_pauseck_par, "ck_macro_pauseck_par", [P [ck; O 8]; P [ck; O 7]]);
     (ck_macro_pauseck, "ck_macro_pauseck", [ck; ck]);
     (ck_macro_await_slow, "ck_macro_await_slow", [N; N; O 5]);
     (ck_macro_multi, "ck_macro_multi", [ck; ck; P[ck; O 5]]);
     (ck_macro_pause_topck, "ck_macro_pause_topck", [ck; ck]);
     (ck_macro_nested, "ck_macro_nested", [N; O 3]);
     (ck_done, "ck_done", [ck]);
     (nested_clocks, "nested_clocks", [ S(P [O 1; O 3], P [O 2; O 4]) ]);
     (nested_clocks_direct, "nested_clocks_direct", [ S(O 1, O 2) ]);
     (nested_clocks_direct, "nested_clocks_direct2", [ S(O 1, O 2) ]);
     (nested_clocks_direct, "nested_clocks_direct3", [ S(O 1, O 2) ]);
     (macro_instant, "macro_instant", [O 2; O 3; N; O 4]);
     (macro_instant_loop, "macro_instant_loop", [O 2; O 3; O 2; P[O 3; O 4]; O 2; P[O 3; O 4]]);
     (await_slow_loop, "await_slow_loop", [N; v; v; N; v; v]);
    ]
