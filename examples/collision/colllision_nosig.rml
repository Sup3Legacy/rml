open Process
open Utils

let dt = 2.0

(*** Definition of types and related functions *)

type ('a, 'state) agent_state =
    { mutable a_pos : vector;
      a_kill : (unit, unit list) event;
      a_relocate : (unit, unit list) event;
      a_state : 'state }

type ('a, 'state) state =
  | Agent of ('a, 'state) agent_state
  | Wall of (vector -> vector -> float -> vector option) (* pos -> speed -> rad -> new_speed *)

let mk_pos agent_ck init =
  init

let mk_state pos st global_area_ck =
  signal kill at global_area_ck in
  signal relocate at global_area_ck in
  { a_pos = pos;
    a_state = st;
    a_kill = kill;
    a_relocate = relocate }

let rec only_agents l = match l with
| [] -> []
| Agent b as x :: l -> b::(only_agents l)
| Wall _ :: l -> only_agents l

let print_walls_list l =
  let string_of_wall w = match w with
  | S -> "S"
  | N -> "N"
  | E -> "E"
  | W -> "W"
  in
  List.iter (fun w -> print_string ((string_of_wall w)^", ")) l

let sub_walls walls q =
  let filter_wall wall = match q, wall with
  | NW, (N | W) -> true
  | NW, _ -> false
  | NE, (N | E) -> true
  | NE, _ -> false
  | SW, (S | W) -> true
  | SW, _ -> false
  | SE, (S | E) -> true
  | SE, _ -> false
  in
  List.filter filter_wall walls

let wall_thickness = 1.0
let wall_rect r w = match w with
| S ->
    mk_rect (r.r_x -. wall_thickness) (r.r_y -. wall_thickness)
      (2. *. wall_thickness +. r.r_w) (wall_thickness)
| N ->
    mk_rect (r.r_x -. wall_thickness) (r.r_y +. r.r_h)
      (2. *. wall_thickness +. r.r_w) wall_thickness
| W ->
    mk_rect (r.r_x -. wall_thickness) (r.r_y -. wall_thickness)
      wall_thickness (2. *. wall_thickness +. r.r_h)
| E ->
    mk_rect (r.r_x +. r.r_w) (r.r_y -. wall_thickness)
      wall_thickness (2. *.wall_thickness +. r.r_h)

let bounce_wall r w pos sp rad = match w with
| S ->
    if pos.v_y +. (dt *. sp.v_y) -. rad < r.r_y then
      Some (mk_vector sp.v_x (-. sp.v_y))
    else
      None
| N ->
    if pos.v_y +. (dt *. sp.v_y) +. rad > r.r_y +. r.r_h then
      Some (mk_vector sp.v_x (-. sp.v_y))
    else
      None
| W ->
    if pos.v_x +. (dt *. sp.v_x) -. rad < r.r_x then
      Some (mk_vector (-. sp.v_x) sp.v_y)
    else
      None
| E ->
    if pos.v_x +. (dt *. sp.v_x) +. rad > r.r_x +. r.r_w then
      Some (mk_vector (-. sp.v_x) sp.v_y)
    else
      None

type boundary_kind = Boundary | BrickWall

(*** Agents *)
let process agent pos st move at_death global_add global_area_ck area env vp =
  let me = mk_state pos st global_area_ck in
  do
    do
      run (move me area env)
    until me.a_relocate -> emit global_add (me.a_pos, me.a_state, move, at_death) done
  until me.a_kill -> at_death () done

(** Wall *)
let process wall r w area env =
  let me = Wall (bounce_wall r w) in
  loop
    emit area(me);
    await env;
  end

let process draw_wall vp (r, k) =
  let c = match k with BrickWall-> Mlsdl_types.Red | Boundary -> Mlsdl_types.Grey in
  let sp =
    Mlsdl_client.create_sprite_box vp (Mlsdl_types.mk_pos r.r_x r.r_y)
      (int_of_float r.r_w) (int_of_float r.r_h) c
  in
  loop
    Mlsdl_client.set_sprite_pos sp r.r_x r.r_y;
    Mlsdl_client.draw_sprite sp;
    pause topck
  end

(*** Area *)
let process forward_child s s_map =
  let forward b = match b with
  | Agent b ->
      let s = Geomap.find_by_pos b.a_pos s_map in
      emit s (Agent b)
  | Wall _ -> ()
  in
  run (foreach s forward)

let process adder add global_add global_area_ck area env vp =
  let process launch_agent (pos, st, move, at_death) =
    run (agent pos st move at_death global_add global_area_ck area env vp)
  in
  run (foreach_p add launch_agent)

let process composed_adder add add_map =
  let forward ((pos, _, _, _) as x) =
    let s = Geomap.find_by_pos pos add_map in
    emit s x
  in
  run (foreach add forward)

(* send to neighbors *)
let process parent_forwarder r global_add area parent_area =
  let forward l =
    (*print_string "Forwarding to parents"; print_int (List.length l); print_newline();*)
    let l = only_agents l in
    let l, outsiders = List.partition (fun b -> is_inside r b.a_pos) l in
    (*if outsiders <> [] then (
      print_string "Relocating "; print_int (List.length outsiders); print_newline()
     ); *)
    let in_borders = List.filter (fun b -> is_in_border r b.a_pos) l in
    List.iter (fun x -> emit parent_area (Agent x)) in_borders;
    List.iter (fun x -> (*print_endline "emit relocate";*) emit x.a_relocate) outsiders
  in
  run (on_signal area forward)

(* dispatch to child areas *)
let process dispatcher r area local_areas =
  let dispatch b = match b with
  | Wall _ -> ()
  | Agent b ->
      let l = List.map (fun q -> Geomap.find q local_areas) (near_quads_from_pos r b.a_pos) in
      List.iter (fun area -> emit area (Agent b)) l
  in
  run (foreach area dispatch)

let process local_walls r walls area env vp =
  let process wall w =
    run (wall r w area env)
  in
  run (process_iter wall walls)
  ||
  let rects =
    List.map
      (fun d -> wall_rect r d, if List.mem d walls then BrickWall else Boundary)
      [N; S; E; W]
  in
  run (process_iter (draw_wall vp) rects)

let process click_divider global_area_ck r clicks from_children divide local_divide =
  let relocate_one b = match b with
  | Agent a -> emit a.a_relocate
  | _ -> ()
  in
  run (foreach clicks (fun pos -> if is_inside r pos then emit local_divide))
  ||
  await local_divide;
  pause;
  List.iter relocate_one (pre? from_children);
  pause global_area_ck;
  emit divide

let rec process area area_ck global_area_ck agent_ck global_add add env parent level r walls vp clicks =
  signal from_children at area_ck in
  let rec process behave level =
    match level with
    | 0 ->
        signal divide at global_area_ck in
        signal local_divide at area_ck in
        signal local_env at agent_ck in
        do
          run (forwarder from_children local_env)
          ||
          run (forwarder env local_env)
          ||
          run (local_walls r walls from_children local_env vp)
        until local_divide done
        ||
        do
          run (adder add global_add global_area_ck from_children local_env vp)
        until divide -> run (behave 1) done
        ||
        run (click_divider global_area_ck r clicks from_children divide local_divide)
      | _ ->
          let add_map, env_map, p =
            init_child_areas area_ck global_area_ck agent_ck global_add
              level from_children r walls vp clicks
          in
          run p
          ||
          run (dispatcher r from_children env_map)
          ||
          run (composed_adder add add_map)
          ||
          run (forward_child env env_map)
  in
  run (behave level)
  ||
  match parent with
  | None -> ()
  | Some (parent_area, pos) -> run (parent_forwarder r global_add from_children parent_area)


and init_child_areas area_ck global_area_ck agent_ck global_add level from_children r walls vp clicks =
  let add_area (add_map, env_map, p) q =
    let add, env, newp = mk_area area_ck global_area_ck agent_ck global_add
        (Some (from_children, q)) (level - 1) (sub_rect r q) (sub_walls walls q) vp clicks in
    let add_map = Geomap.add q add add_map in
    let env_map = Geomap.add q env env_map in
    let p = process (run p || run newp) in
    (add_map, env_map, p)
  in
  List.fold_left add_area (Geomap.empty r, Geomap.empty r, process ()) [NW; SW;NE;SE]

and mk_area ck global_area_ck agent_ck global_add parent level r walls vp clicks =
  signal add at ck in
  signal env at ck in
  let process area_p =
    newclock area_ck in
      run (area area_ck global_area_ck agent_ck global_add add env parent level r walls vp clicks)
  in
  add, env, area_p

let mk_global_area agent_ck level r vp =
  signal external_add at topck in
  signal clicks at topck in
  let process area_p =
   newclock global_ck schedule (fun nb -> 0, nb) in
    signal add at global_ck in
    signal env at global_ck in
    newclock area_ck schedule (fun nb -> 0, nb) in
      run (area area_ck area_ck agent_ck add add env None level r [N; S; W; E] vp clicks)
      ||
      run (forwarder external_add add)
  in
  external_add, clicks, area_p

(** Simple ball *)
type ball_state =
    { mutable b_speed : vector;
      b_sprite : float Mlsdl_client.sprite;
      b_rad : float;
      b_weight : float;
      b_lethal : bool }

let do_stuff () =
  let r = ref 0 in
  for i = 1 to 10000 do
    r := (!r + 29378) mod 5243552
  done

let process_collision me s b = match b with
| Agent a ->
    let new_pos_a = add_vector a.a_pos (scalar_mult dt a.a_state.b_speed) in
    let new_pos_me = add_vector me.a_pos (scalar_mult dt me.a_state.b_speed) in

    let d2 = dist2 new_pos_a new_pos_me in
    if d2 > 0. && (sqrt d2) < a.a_state.b_rad +. me.a_state.b_rad then (

      if me.a_state.b_lethal or a.a_state.b_lethal then (
        if me.a_state.b_lethal then emit a.a_kill;
        s
       ) else (
        (*print_endline "collision detected";*)
        (*collision detected*)
        (* formula from http://fr.wikipedia.org/wiki/Choc_Ã©lastique *)
        let sum_m = a.a_state.b_weight +. me.a_state.b_weight in
        let s_I = (* VI = (m1.V1 + m2.V2) / (m1 + m2) *)
          add_vector
            (scalar_mult (me.a_state.b_weight /. sum_m) me.a_state.b_speed)
            (scalar_mult (a.a_state.b_weight /. sum_m) a.a_state.b_speed)
        in
        let s = (* v_1' = 2 VI - v_1 *)
          add_vector
            (scalar_mult 2.0 s_I)
            (scalar_mult (-1.0) me.a_state.b_speed)
        in
        s
       )
    ) else
      s

| Wall _ -> s

let process_wall me s b = match b with
| Wall bounce ->
    (match bounce me.a_pos s me.a_state.b_rad with
    | None -> s
    | Some new_s -> new_s)
| Agent _ -> s

let process compute_pos_ball me others =
  (*do_stuff ();*)
  let new_speed = List.fold_left (process_collision me) me.a_state.b_speed others in
  let new_speed = List.fold_left (process_wall me) (new_speed) others in
  let new_pos = add_vector me.a_pos (scalar_mult dt new_speed) in
  pause;
  me.a_pos <- new_pos;
  me.a_state.b_speed <- new_speed;
  Mlsdl_client.set_sprite_pos me.a_state.b_sprite (new_pos.v_x -. me.a_state.b_rad) (new_pos.v_y -. me.a_state.b_rad);
  Mlsdl_client.draw_sprite me.a_state.b_sprite

let process ball me area env =
  loop
    emit area(Agent me);
    await env(others) in
    run (compute_pos_ball me others)
  end


(* test case *)
let nb_balls = ref 400
let level = ref 0
let max_speed = 0.2

let w = 800.
let h = 600.
let margin = 20.0
let sc_w = int_of_float (w +. 2. *. margin)
let sc_h = int_of_float (h +. 2. *. margin)

let _ = Random.self_init ()

(*
let process print_body vp p =
  let sp = Mlsdl_client.create_sprite_from_file vp Mlsdl_types.null_float_pos 16 16 "ball.png" in
  loop
    pause topck;
    (* shift by (8., 8.) to print at the correct center *)
    Mlsdl_client.set_sprite_pos sp (p.v_x -. 4.0) (p.v_y -. 4.0);
    Mlsdl_client.draw_sprite sp;
  end
*)

let random_ball_state vp =
  { b_speed = mk_pos topck (random_vector (-. max_speed) (-. max_speed) max_speed max_speed);
    b_sprite = Mlsdl_client.create_sprite_from_file vp Mlsdl_types.null_float_pos 4 4 "ball_small.png";
    b_weight = 5.0;
    b_rad = 2.0;
    b_lethal = false; }

let mk_ball vp top_adder =
  let pos = mk_pos topck (random_vector 0.0 0.0 w h) in
  let st = random_ball_state vp in
  let at_death () = Mlsdl_client.clear_sprite st.b_sprite in
  emit top_adder (pos, st, ball, at_death)
 (* run (print_body vp pos) *)

let mk_pacman vp top_adder =
  let pos = mk_pos topck (random_vector 0.0 0.0 w h) in
  let st =
    { b_speed = mk_pos topck (random_vector (-. max_speed) (-. max_speed) max_speed max_speed);
      b_sprite = Mlsdl_client.create_sprite_from_file vp Mlsdl_types.null_float_pos 32 32 "pacman.png";
      b_weight = 5000.0;
      b_rad = 16.0;
      b_lethal = true }
  in
  emit top_adder (pos, st, ball, fun () -> ())

let process click_watcher vp clicks =
  let process_event (mev, pos) = match mev with
  | Mlsdl_types.Mleft_up ->
      let pos = Mlsdl_client.translate_pos pos vp in
      let v = mk_vector pos.Mlsdl_types.p_x pos.Mlsdl_types.p_y in
      emit clicks(v)
  | _ -> ()
  in
  loop
    let evs = Mlsdl_client.flush_mouse_events () in
    List.iter process_event evs;
    pause topck
  end

let parse_cli () =
  Rmlarg.parse
    ["-nb-balls", Rmlarg.Set_int nb_balls, "Number of balls";
     "-level", Rmlarg.Set_int level, "Starting level"]
    ignore
    ""

let process show_fps =
  let prev = ref (Unix.gettimeofday ()) in
  loop
    let new_time = Unix.gettimeofday () in
    let fps = int_of_float (5.0 /. (new_time -. !prev)) in
    prev := new_time;
    Mlsdl_client.draw_info_box ((string_of_int fps)^" FPS");
    pause; pause; pause; pause; pause
  end

let process key_listener vp top_adder =
  loop
    let evs = Mlsdl_client.flush_key_events () in
    if List.mem "b" evs then (
      for i=1 to 10 do
        mk_ball vp top_adder
      done
     );

    if List.mem "p" evs then
      mk_pacman vp top_adder;
    pause
  end

let process main =
  parse_cli ();
  (* setup screen *)
  let vp_rect = Mlsdl_types.mk_rect (-. margin) (-. margin) (float_of_int sc_w) (float_of_int sc_h) in
  let sc_rect = Mlsdl_types.mk_rect 0 0 sc_w sc_h in
  Mlsdl_client.start_screen (Mlsdl_types.Window (sc_w, sc_h)) sc_w sc_h Mlsdl_types.Green 60;
  let vp = Mlsdl_client.create_float_viewport vp_rect sc_rect in
  let top_adder, clicks, top_area_p = mk_global_area topck !level (mk_rect 0. 0. w h) vp in
  run top_area_p
  ||
  for i = 1 to !nb_balls do
    mk_ball vp top_adder
  done
  ||
  run (click_watcher vp clicks)
  ||
  run show_fps
  ||
  run (key_listener vp top_adder)


