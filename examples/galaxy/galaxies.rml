open Rmlsdl

let random_int min max =
  min + Random.int (max - min)

let random_float min max =
  min +. Random.float (max -. min)

(* Vector operations*)
type vector = { v_x : float; v_y : float; v_z : float }

let mk_vector x y z =
  { v_x = x; v_y = y; v_z = z }

let zero_vector = { v_x = 0.0; v_y = 0.0; v_z = 0.0 }

let random_vector xmin ymin xmax ymax =
  { v_x = random_float xmin xmax;
    v_y = random_float ymin ymax;
    v_z = 0.0; }

let dist2 v1 v2 =
  (v2.v_x -. v1.v_x) *. (v2.v_x -. v1.v_x)
    +. (v2.v_y -. v1.v_y) *. (v2.v_y -. v1.v_y)
    +. (v2.v_z -. v1.v_z) *. (v2.v_z -. v1.v_z)

let unit_vector v1 v2 =
  let d2 = dist2 v1 v2 in
  let d = sqrt d2 in
  { v_x = (v2.v_x -. v1.v_x) /. d;
    v_y = (v2.v_y -. v1.v_y) /. d;
    v_z = (v2.v_z -. v1.v_z) /. d }

let normal_unit_vector v1 v2 =
  let d2 = dist2 v1 v2 in
  let d = sqrt d2 in
  { v_x = -. (v2.v_y -. v1.v_y) /. d;
    v_y = (v2.v_x -. v1.v_x) /. d;
    v_z = (v2.v_z -. v1.v_z) /. d }

let add_vector v1 v2 =
  { v_x = v1.v_x +. v2.v_x;
    v_y = v1.v_y +. v2.v_y;
    v_z = v1.v_z +. v2.v_z }

let scalar_mult a v =
  { v_x = a *. v.v_x; v_y = a *. v.v_y; v_z = a *. v.v_z;  }

let center_float r =
  { v_x = r.r_x +. (r.r_w /. 2.0);
    v_y = r.r_y +. (r.r_h /. 2.0);
    v_z = 0.0 }

(* Data structures *)

let gen_id =
  let counter = ref 0 in
  fun () ->
    incr counter;
    !counter

type body =
    { b_id : int;
      mutable b_pos : vector;
      mutable b_vel : vector;
      b_weight : float; }

let mk_body pos v weight =
  { b_id = gen_id ();
    b_pos = pos;
    b_vel = v;
    b_weight = weight;
  }

(* Computing forces *)
let g = 3.0

let force pos1 (pos2, w2) =
  let d2 = dist2 pos1 pos2 in
  if (d2 <> 0.0) then
    let f12 = (g *. w2) /. d2 in
    (*print_float f12; print_newline (); *)
    scalar_mult f12 (unit_vector pos1 pos2)
  else
    zero_vector

let compute_pos dt st all =
  let add_force f body = add_vector (force st.b_pos body) f in
  let f = List.fold_left add_force zero_vector all in
  st.b_vel <- add_vector st.b_vel (scalar_mult dt f);
  st.b_pos <- add_vector st.b_pos (scalar_mult dt st.b_vel)


(** Body processes *)
let process body st dt env =
  loop
    emit env(st.b_pos, st.b_weight);
    await env(all) in
    compute_pos (pre? dt) st all
  end

let process fixed_body st dt env =
  loop
    emit env(st.b_pos, st.b_weight);
    pause;
  end

(* Main system *)

let enable_graphics = true

let process body_sprite st sp =
  if enable_graphics then (
    loop
      Rmlsdl.set_sprite_pos sp st.b_pos.v_x st.b_pos.v_y;
      Rmlsdl.draw_sprite sp;
      pause
    end
   )

let process window =
  if enable_graphics then (
    Rmlsdl.create_fullscreen_window ();
    ignore (Rmlsdl.create_world 1680 1050 Rmlsdl.Black);
    loop
      Rmlsdl.process_events ();
      Rmlsdl.update None;
      pause
    end
   )

let random_pos_planet c_x c_y dmin dmax =
  let rand_away z d =
    if Random.bool () then z +. d else z -. d
  in
  let d = random_float dmin dmax in
  let x = random_float (c_x -. d) (c_x +. d) in
  let dy = sqrt ( (d *. d) -. ((x -. c_x) *. (x -. c_x)) ) in
  let y = rand_away c_y dy in
  mk_vector x y 0.0

let process solar_system vp_rect sc_rect env dt =
  let vp = Rmlsdl.create_float_viewport vp_rect sc_rect in
  let center = center_float vp_rect in
  let process sun dt env =
    let st = mk_body center zero_vector 8000.0 in
    let sp = Rmlsdl.create_sprite_from_file vp null_float_pos "sun.png" in
    run (body st dt env)
    ||
    run (body_sprite st sp)
  in
  let process planet dt env =
   let pos = random_pos_planet center.v_x center.v_y 100.0 200.0 in
   let st = mk_body pos
     (scalar_mult 10.0 (normal_unit_vector pos center))
     (random_float 0.01 0.01)
   in
   (*let sp = Rmlsdl.create_sprite_circle 5 Rmlsdl.Blue in*)
    let sp = Rmlsdl.create_sprite_from_file vp null_float_pos "earth.png" in
    run (body st dt env)
    ||
    run (body_sprite st sp)
  in
  pause;
  run (sun dt env)
  ||
  pause;
  for i = 1 to 8 dopar
    run (planet dt env)
  done

let _ = Random.self_init ()

let process main =
  signal dt default 0.0 gather (+.) in
  signal env in
  let vp_rect = mk_rect 0.0 0.0 800.0 500.0 in
  let sc_rect = mk_rect 0 0 800 500 in
  run (solar_system vp_rect sc_rect env dt)
  ||
  let vp_rect = mk_rect 1e7 0.0 800.0 500.0 in
  let sc_rect = mk_rect 840 0 800 500 in
  run (solar_system vp_rect sc_rect env dt)
  ||
  let vp_rect = mk_rect 0.0 1e7 500.0 500.0 in
  let sc_rect = mk_rect 0 525 800 500 in
  run (solar_system vp_rect sc_rect env dt)
  ||
  let vp_rect = mk_rect 1e7 1e7 800.0 500.0 in
  let sc_rect = mk_rect 840 525 800 500 in
  run (solar_system vp_rect sc_rect env dt)
  ||
  loop
    emit dt(1.0);
    pause
  end
  ||
  run window

(*
let process solar_system pck dt env =
 newclock ck in
  let st = ref (mk_solar_system_state ()) in
  signal local_env in
  signal local_dt in
  loop
    await env(all) in
    emit st.pos (compute_move dt st all)
  end
  ||
  do
    for i = 1 to n dopar
      run (planet local_dt local_env)
    done
  when local_dt done
  ||
  emit env(pre? st.pos);
  loop
    let n = choose_number_steps () in
    emit local_env (last? local_env);
    run (sustain n local_dt (pre? dt /. (float_of_int n)));
    emit st.pos (add_local_move (pre? local_env));
    pause ck;
    emit env(pre? st.pos);
    pause pck
  end
*)

(* n >= 2 *)
(*
let process pauseclock_at_most n ck topck =
  signal nb default 0 gather (+) in
  loop
    emit nb (n - pre? nb);
    pause topck
  end
  ||
  loop
    emit nb (-1);
    pause ck
  end
  ||
  loop
    await nb(1) in
    pauseclock ck
  end
*)
