(****************************************************)
(****************************************************)
(** Multiclock version ******************************)
(****************************************************)
(****************************************************)

open Mlsdl
open Rmlsdl
open Utils

let enable_graphics = true

let compute_pos dt st all =
  let add_force f body = add_vector (force body st.b_pos) f in
  let f = List.fold_left add_force zero_vector all in
  st.b_vel <- add_vector st.b_vel (scalar_mult dt f);
  st.b_pos <- add_vector st.b_pos (scalar_mult dt st.b_vel)

(** Body processes *)
let process body st dt env =
  loop
    emit env(st.b_pos, st.b_weight);
    await env(all) in
    compute_pos (pre? dt) st all
  end

let process fixed_body st dt env =
  loop
    emit env(st.b_pos, st.b_weight);
    pause;
  end

let process body_sprite st sp =
  if enable_graphics then (
    loop
      Mlsdl.set_sprite_pos sp st.b_pos.v_x st.b_pos.v_y;
      Mlsdl.draw_sprite sp;
      pause
    end
   )

let choose_number_steps _ = 30

let compute_weight all =
  List.fold_left (fun t (_, w) -> w +. t) 0.0 all

let process composed_body pck p st dt env =
  loop
    await env(all) in
    compute_pos (pre? dt) st all
  end
  ||
  newclock ck in
    signal local_dt default 0.0 gather (+.) in
    signal local_env in
    loop
      let n = choose_number_steps st in
      List.iter (fun v -> emit local_env v) (last? local_env);
      run (sustain n local_dt (pre? dt /. (float_of_int n)));
      pause ck;
      let total_weight = compute_weight (pre? local_env) in
      emit env(st.b_pos, total_weight);
      pause pck
    end
    ||
    do
      run (p local_dt local_env)
    when local_dt done


let process container time_step p =
  signal dt default 0.0 gather (+.) in
  signal env in
  loop
    emit dt(time_step);
    pause
  end
  ||
  run (p dt env)



let random_pos_planet c_x c_y dmin dmax =
  let rand_away z d =
    if Random.bool () then z +. d else z -. d
  in
  let d = random_float dmin dmax in
  let x = random_float (c_x -. d) (c_x +. d) in
  let dy = sqrt ( (d *. d) -. ((x -. c_x) *. (x -. c_x)) ) in
  let y = rand_away c_y dy in
  mk_vector x y 0.0

let process planet center vp dt env =
  let pos = random_pos_planet center.v_x center.v_y 100.0 200.0 in
  let st = mk_body pos
      (scalar_mult 10.0 (normal_unit_vector pos center))
      (random_float 0.01 0.01)
  in
  (*let sp = Rmlsdl.create_sprite_circle 5 Rmlsdl.Blue in*)
  let sp = Mlsdl.create_sprite_from_file vp null_float_pos "earth.png" in
  run (body st dt env)
  ||
  run (body_sprite st sp)

let process sun center vp dt env =
  let st = mk_body center zero_vector 8000.0 in
  let sp = Mlsdl.create_sprite_from_file vp null_float_pos "sun.png" in
  run (body st dt env)
  ||
  run (body_sprite st sp)

let process solar_system center sc_rect vp dt env =
  let pos = random_pos_planet center.v_x center.v_y 1e6 2e6 in
  let st = mk_body pos
      (scalar_mult 1000.0 (normal_unit_vector pos center))
      8000.0
  in
  let vp_rect = mk_rect 0.0 0.0 800.0 500.0 in
  let local_vp = Mlsdl.create_float_viewport vp_rect sc_rect in
  let center = center_float vp_rect in
  let process p local_dt local_env =
    run (sun center local_vp local_dt local_env)
    ||
    for i = 1 to 10 dopar
      run (planet center local_vp local_dt local_env)
    done
    ||
    loop
      Mlsdl.update None;
      pause; pause; pause; pause; pause; pause
    end
  in
  run (composed_body topck p st dt env)
  ||
  let sp = Mlsdl.create_sprite_from_file vp null_float_pos "sun.png" in
  run (body_sprite st sp)

let process black_hole pos vp dt env =
  let st = mk_body pos zero_vector 8000000.0 in
  let sp = Mlsdl.create_sprite_from_file vp null_float_pos "blackhole.png" in
  run (fixed_body st dt env)
  ||
  run (body_sprite st sp)

let _ = Random.self_init ()

let process main =
  let vp_rect = mk_rect 0.0 0.0 8e6 5e6 in
  let sc_rect = mk_rect 0 525 800 500 in
  let center = center_float vp_rect in
  let _, window_p = Rmlsdl.window Fullscreen 1680 1050 Black in
  let vp = Mlsdl.create_float_viewport vp_rect sc_rect in
  let process p dt env =
    let sc_rect = mk_rect 840 0 800 500 in
    run (solar_system center sc_rect vp dt env)
    ||
    let sc_rect = mk_rect 0 0 800 500 in
    run (solar_system center sc_rect vp dt env)
    ||
    run (black_hole center vp dt env)
  in
  pause; run (container 1.0 p)
  ||
  run window_p

(* n >= 2 *)
(*
let process pauseclock_at_most n ck topck =
  signal nb default 0 gather (+) in
  loop
    emit nb (n - pre? nb);
    pause topck
  end
  ||
  loop
    emit nb (-1);
    pause ck
  end
  ||
  loop
    await nb(1) in
    pauseclock ck
  end
*)
