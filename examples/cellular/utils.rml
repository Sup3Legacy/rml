open Rmlarg

(* config *)
let n_ref = ref 16
let slices_ref = ref 2
let debug = ref false
let print = ref false

let _ =
  let options =
    ["-nb", Set_int n_ref, "number of elements";
     "-slices", Set_int slices_ref, "number_of_slices";
     "-debug", Set debug, "debug mode";
     "-print", Set print, "print results"]
  in
  Rmlarg.parse options ignore "Usage: "

let n = !n_ref
let slices = !slices_ref
let slice_size = n / slices


(* boolean xor transition function *)
let xor a b = (a && (not b)) or ((not a) && b)
let transition x_l x x_r = xor x_l (xor x x_r)
let default_state = false

let initial_state =
  let a = Array.make n false in
  for i=0 to (n-1)/4 do
    a.(4*i) <- true;
    a.(4*i+1) <- true;
    a.(4*i+3) <- true
  done;
  a
let print_state x =
  if x then print_string "1" else print_string "0"

(**)
let process init_array p n =
  let x0 = run p 0 in
  let a = Array.make n x0 in
  for i=1 to n-1 do
    let v = run p i in
    a.(i) <- v
  done;
  a

let process init_memory_array n def =
  run init_array (fun _ -> process (memory m last def in m)) n

let default_slice = Array.make (slice_size/2) default_state

(* a true modulo function, unlike OCaml mod which is the remainder of the division
    and doesn't have the good behaviour for negative integers *)
let rec mmod x y =
  if x < 0 then mmod (x+y) y
  else if x >= y then mmod (x-y) y
  else x

(**)

let print_state_array a =
  Array.iter (fun x -> print_string " "; print_state x) a;
  print_newline ()
