(* config *)
let n = 8
let slices = 2
let slice_size = n / slices
let debug = ref false

(* boolean xor transition function *)
let xor a b = (a && (not b)) or ((not a) && b)
let transition x_l x x_r = xor x_l (xor x x_r)
let default_state = false
(*
let initial_state =
  let a = Array.make n false in
  for i=0 to (n-1)/3 do a.(3*i) <- true done;
  a
*)
let initial_state = [|true; true; false; false; true; false; false; true|]
let print_state x =
  if x then print_string "1" else print_string "0"

(**)
let process init_array p n =
  let x0 = run p 0 in
  let a = Array.make n x0 in
  for i=1 to n-1 do
    let v = run p i in
    a.(i) <- v
  done;
  a

let process init_memory_array n def =
  run init_array (fun _ -> process (memory m last def in m)) n

let default_slice = Array.make (slice_size/2) default_state

(* a true modulo function, unlike OCaml mod which is the remainder of the division
    and doesn't have the good behaviour for negative integers *)
let rec mmod x y =
  if x < 0 then mmod (x+y) y
  else if x >= y then mmod (x-y) y
  else x

(**)

let print_state_array a =
  Array.iter (fun x -> print_string " "; print_state x) a;
  print_newline ()
