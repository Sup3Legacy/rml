(* ---------------------------- *)
(* Types                        *)
(* ---------------------------- *)
type routage_kind = LER | PDL

type position =
    { x: int;
      y: int; }

type node = 
    { id: int;
      mutable pos: position;
      mutable date: int;
      pos_tbl_ler: position Pos_tbl.t;
      pos_tbl_pdl: position Pos_tbl.t;
      mutable neighbors: node list; }

type packet_header =
  | H_LER
  | H_PDL of pdl_info option

and pdl_info =
    { pdl_id: int;
      pdl_pos: position;
      pdl_pos_age: int; 
      mutable pdl_overhead: int; }

type packet =
    { mutable header: packet_header;
      src_id: int;
      dest_id: int;
      mutable dest_pos: position;
      mutable dest_pos_age: int;
      (* to compute statistics *)
      mutable route: node list;
      mutable anchors: (node * node option * int * int) list; 
      mutable overhead: int; }


(* ---------------------------- *)
(* Global values                *)
(* ---------------------------- *)
let () = Init.configure()

let nb_instants = !Init.nb_instants

(* simulation space *)
let max_x = !Init.max_x
let max_y = !Init.max_y

let area_size_x = !Init.area_size_x
let area_size_y = !Init.area_size_y

let nb_area_x = 
  if max_x mod area_size_x = 0 then 
    max_x / area_size_x 
  else 
    (max_x / area_size_x) + 1
let nb_area_y = 
  if max_y mod area_size_y = 0 then 
    max_y / area_size_y 
  else 
    (max_y / area_size_y) + 1


let hello_array = 
  Array.make_matrix nb_area_x nb_area_y 
    ((Obj.magic()): (node, node list) event)


(* nodes *)
let nb_nodes = !Init.nb_nodes
let coverage_range = !Init.coverage_range
let coverage_range2 = coverage_range * coverage_range
let speed = !Init.speed

let main_node = ref 0

(* packets *)
let pdl_proba = !Init.pdl_proba
let pdl_forecast = !Init.pdl_forecast

let msg_proba = !Init.msg_proba
let msg_len = !Init.msg_len

(* Outputs *)
let with_graphics = !Init.with_graphics

(* ---------------------------- *)
(* Misc                         *)
(* ---------------------------- *) 
let distance2 pos1 pos2 = 
  (pos2.x - pos1.x) * (pos2.x - pos1.x) + 
    (pos2.y - pos1.y) * (pos2.y - pos1.y) 
 
(* Creation functions *)
let get_new_id =
  let cpt = ref (-1) in
  fun () ->
    incr cpt;
    !cpt


let make_node pos =
  {  id = get_new_id();
     date = 0;
     pos_tbl_ler = Pos_tbl.make nb_nodes ({x=0; y=0},Pos_tbl.no_info);
     pos_tbl_pdl = Pos_tbl.make nb_nodes ({x=0; y=0},Pos_tbl.no_info);
     neighbors = [];
     pos = pos; }


let make_pdl_info node overhead =
  { pdl_id = node.id;
    pdl_pos = node.pos;
    pdl_pos_age = 0; 
    pdl_overhead = overhead; }


let make_packet header src_node dest =
  let dest_pos, dest_pos_date = 
    match header with
    | H_LER -> Pos_tbl.get src_node.pos_tbl_ler dest 
    | H_PDL _ -> Pos_tbl.get src_node.pos_tbl_pdl dest
  in
  { header = header;
    src_id = src_node.id;
    dest_id = dest;
    dest_pos = dest_pos;
    dest_pos_age = abs (src_node.date - dest_pos_date);
    route = [];
    anchors = [];
    overhead = 0;
  }

let make_ler_packet =  make_packet H_LER 

let make_pdl_packet src_node dest =
  make_packet (H_PDL None) src_node dest

