(* ----------------------------------------------------------------------- *)
(*                       A Prey-Predator System                            *)
(*                                                                         *)
(* Taken from Loft:                                                        *)
(* http://www-sop.inria.fr/mimosa/rp/LOFT/doc/preypred/preypred-paper.html *)
(*                                                                         *)
(* ----------------------------------------------------------------------- *)


type sprite =
    { mutable x: int;
      mutable y: int;
      mutable sx: int;
      mutable sy: int;
      index: int;
(*       behaviors: process array; *)
(*       behav_num: int; *)
      mutable destroy: (unit,unit) event;
      mutable dead: bool; }


let inertia_factor = 10

let min_border_x = 10
let max_border_x = 210
let min_border_y = 10
let max_border_y = 130

let min_collision = 400

let kill_dist2 = 200
let max_pred_speed = 10
let pred_run_step = 1
let predator_visibility = 40000

signal a_pressed,
  b_pressed,
  up_pressed,
  down_pressed,
  left_pressed,
  right_pressed,
  r_pressed,
  l_pressed
    default () gather fun () () -> ()

signal pred_evt: (sprite, sprite list) event default [] gather fun x y -> x::y
signal prey_evt: (sprite, sprite list) event default [] gather fun x y -> x::y

let next_sprite =
  let cpt = ref 0 in
  fun () ->
    incr cpt;
    !cpt

signal tmp default () gather fun () () -> ()

let new_sprite speed =
  { x = Random.int (max_border_x - min_border_x) + min_border_x;
    y = Random.int (max_border_y - min_border_y) + min_border_y;
    sx = Random.int speed;
    sy = Random.int speed;
    index = next_sprite ();
    destroy = tmp;
    dead = false; }

(* ----------------------------------------------------------------------- *)
(* Keyboard                                                                *)
(* ----------------------------------------------------------------------- *)

let process read_key key =
  loop
    if Graphics.key_pressed() then emit key (Graphics.read_key());
    pause
  end

let process key_handler =
  loop
    begin
      if Graphics.key_pressed() then
	match Graphics.read_key() with
	| 'a' -> emit a_pressed
	| 'b' -> emit b_pressed
	| 'i' -> emit up_pressed
	| 'k' -> emit down_pressed
	| 'j' -> emit left_pressed
	| 'l' -> emit right_pressed
	| 'o' -> emit r_pressed
	| 'p' -> emit l_pressed
	| _ -> nothing
    end;
    pause
  end

let process key_processing key_pressed callback =
  loop
    await immediate key_pressed;
    callback ();
    for i = 1 to 10 do pause done
  end

(* ----------------------------------------------------------------------- *)
(* Elementary Behaviors                                                    *)
(* ----------------------------------------------------------------------- *)

(* Inertia *)

let process inertia s =
  loop 
    s.x <- s.sx / inertia_factor + s.sx;
    s.y <- s.sy / inertia_factor + s.sy;
    pause
  end


(* Moves *)

let go_right s dist =
  s.x <- s.x + dist;
  if (s.x > max_border_x) then s.x <- max_border_x

let go_left s dist =
  s.x <- s.x - dist;
  if (s.x < min_border_x) then s.x <- min_border_x

let go_up s dist =
  s.y <- s.y + dist;
  if (s.y > max_border_y) then s.y <- max_border_y
      
let go_down s dist =
  s.y <- s.y - dist;
  if (s.y < min_border_y) then s.y <- min_border_y


let process move s dir_pressed mvt dist =
  loop
    await immediate dir_pressed;
    mvt s dist;
    pause;
  end

let move_right s dist = move s right_pressed go_right dist


(* Collisions *)

let dist2 s1 s2 =
  let dx = s2.x - s1.x in
  let dy = s2.y - s1.y in
  dx*dx+dy*dy

let collision s1 s2 =
  let dx = s2.x - s1.x in
  let dy = s2.y - s1.y in
  if (dist2 s1 s2) <= min_collision then 
    begin
      s1.sx = -s1.sx;
      s1.sy = -s1.sy;
      if dx>0 then go_left s1 dx else go_right s1 (-dx);
      if dy>0 then go_up s1 dy else go_down s1 (-dy);
    end

let process collide me collide_evt =
  loop
    emit collide_evt me;
    await collide_evt(all) in
    List.iter (fun other -> collision me other) all
  end

let process bounce_on_borders s =
  loop
    if s.x < min_border_x then
      (s.sx <- -s.sx; 
       s.x <- min_border_x);
    if s.y < min_border_y then 
      (s.sy <- -s.sy; 
       s.y <- min_border_y);
    if s.x > max_border_x then
      (s.sx <- -s.sx; 
       s.x <- max_border_x);
    if s.y > max_border_y then
      (s.sy <- -s.sy; 
       s.y <- max_border_y);
    pause
  end


(* ----------------------------------------------------------------------- *)
(* Predators                                                               *)
(* ----------------------------------------------------------------------- *)

let chase me target =
  let dx = target.x - me.x in
  let dy = target.y - me.y in
  let d2 = dist2 me target in

  if d2 < kill_dist2 then 
    (emit target.destroy;
     target.dead <- true)
  else if dx > 0 && me.sx < max_pred_speed then
    me.sx <- me.sx + pred_run_step
  else if dx < 0 && -max_pred_speed <  me.sx then
    me.sx <- me.sx - pred_run_step
  else if dy > 0 && me.sy < max_pred_speed then
    me.sy <- me.sy + pred_run_step
  else if dy < 0 && -max_pred_speed < me.sy then
    me.sy <- me.sy - pred_run_step


let process predator me pred_evt prey_evt =
  loop
    emit pred_evt me;
    await prey_evt (all) in
    match
      List.fold_left  
	(fun (min,closest) other ->
	  let d2 = dist2 me other in
	  if me != other && d2 < min then
	    (d2, Some other)
	  else
	    (min, closest))
	(predator_visibility, None)
	all
    with
    | _, None -> nothing
    | _, Some closest -> chase me closest
  end


let process predator_sprite =
  let s = new_sprite 0 in
  run (predator s pred_evt prey_evt);
  ||
  run (move s right_pressed go_right pred_run_step)
  ||
  run (move s left_pressed go_left pred_run_step)
  ||
  run (move s up_pressed go_up pred_run_step)
  ||
  run (move s down_pressed go_down pred_run_step)
  ||
  run (bounce_on_borders s)
  ||
  run (collide s pred_evt)
  ||
  signal suspend default () gather fun () () -> () in
  control run (inertia s) with suspend
  ||
  loop
    await a_pressed;
    emit suspend;
    await b_pressed;
    emit suspend;
  end
