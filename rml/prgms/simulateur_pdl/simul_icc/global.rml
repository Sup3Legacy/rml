(* ---------------------------- *)
(* Types                        *)
(* ---------------------------- *)
type routage_kind = LER | PDL

type position =
    { x: int;
      y: int; 
    }
      
type pos_tbl = (position * int) array (* (pos * date) array *)

type node = 
    {  node_id: int;
       mutable node_date: int;
       mutable node_pos: position;

       node_pos_tbl_ler: pos_tbl;
       node_pos_tbl_pdl: pos_tbl;
       mutable node_neighbors: hello_info list;

       mutable node_last_dir: int;
       mutable node_dest: position;
   }


and packet_header =
  | H_LER
  | H_PDL of pdl_info option

and 'a packet =
    { mutable packet_header: packet_header;

      packet_src_id: int;

      packet_dest_id: int;
      mutable packet_dest_pos: position;
      mutable packet_dest_pos_age: int;

      packet_msg_len: int;

      mutable packet_route: node list;
      mutable packet_anchors: (node * node option * int * int) list;
      mutable packet_overhead: int;
    }

and pdl_info =
    { mutable pdl_id: int;
      mutable pdl_pos: position;
      mutable pdl_pos_age: int; (* may be < 0 if the pos is estimated *)

      mutable pdl_overhead: int;
   }

and hello_info =
    { hello_id: int;
      hello_pos: position;
      hello_node: node;
    }


(* ---------------------------- *)
(* Configuration                *)
(* ---------------------------- *)
let with_graphics = ref true

let prefix = ref "simul"
let with_stat = ref false
let set_prefix s =
  with_stat := true;
  prefix := s

(* node *)
let nb_node = ref 500

let dist_couv = ref 100
let dist_couv2 = ref (!dist_couv * !dist_couv)

let set_couv n =
  dist_couv := n;
  dist_couv2 := !dist_couv * !dist_couv

(* simulation space size *)
(* taille de l'espace de simulation *)
let maxx = ref 1000
let maxy = ref 1000

let set_size s =
  let x = int_of_float (sqrt s) in
  let y = int_of_float (s /. (float_of_int x)) in
  maxx := x;
  maxy := y

(* taille d'une area *)
let size_x = ref 0
let size_y = ref 0

let nb_area_x = ref 0
let nb_area_y = ref 0 

(* message *)
let msg_proba = ref 50
let msg_len = ref 1

let pdl_proba = ref 100.0
let pdl_forecast = ref 20

(* density *)
let set_density d =
  let taille = float_of_int (!maxx * !maxy) in
  let portee =
    int_of_float 
      (sqrt(d *. taille /. (2.0 *. 3.14 *. float_of_int(!nb_node))))
  in
  set_couv portee

(* ---------------------------- *)
(* Global values                *)
(* ---------------------------- *)
let no_info = -10000
let main_node = ref 1

signal tmp: (hello_info, hello_info list) event
let hello_array = ref (Array.make_matrix !nb_area_x !nb_area_y tmp)
(*    ((Obj.magic()): (info_hello, info_hello list) event)*)

(* output chennel *)
let inst_dist_age_ler_ch = ref (Obj.magic())
let inst_dist_age_pdl_ch = ref (Obj.magic())
let overhead_ch = ref (Obj.magic())
let route_len_ch = ref (Obj.magic())
let anchor_ch = ref (Obj.magic())

let init () =
  size_x := 2 * !dist_couv;
  size_y := 2 * !dist_couv;
  nb_area_x := 
    if !maxx mod !size_x = 0 then !maxx / !size_x else (!maxx / !size_x) + 1;
  nb_area_y :=
    if !maxy mod !size_y = 0 then !maxy / !size_y else (!maxy / !size_y) + 1;
  hello_array := Array.make_matrix !nb_area_x !nb_area_y tmp;
  prefix :=
    !prefix 
    ^"-nb_node_"^(string_of_int !nb_node)
    ^"-maxx_"^(string_of_int (!maxx))
    ^"-dist_couv_"^(string_of_int (!dist_couv))
    ^"-msg_proba_"^(string_of_int (!msg_proba))
    ^"-msg_len_"^(string_of_int (!msg_len))
    ^"-pdl_proba_"^(string_of_float (!pdl_proba))
    ^"_";
  inst_dist_age_ler_ch := open_out (!prefix^"inst_dist_age_ler");
  inst_dist_age_pdl_ch := open_out (!prefix^"inst_dist_age_pdl");
  overhead_ch := open_out (!prefix^"overhead");
  route_len_ch := open_out (!prefix^"route_len");
  anchor_ch := open_out (!prefix^"anchor")

(* ---------------------------- *)
(* Misc                         *)
(* ---------------------------- *) 
let distance2 x1 y1 x2 y2 = 
  (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) 

let get_new_id =
  let cpt = ref (-1) in
  fun () ->
    incr cpt;
    !cpt
      

(* Creation fonctions *)

let make_pos x y =
  { x = x;
    y = y;
  }

let new_node x y =
  {  node_id = get_new_id();
     node_date = 0;

     node_pos_tbl_ler = Array.make !nb_node (make_pos 0 0,no_info);
     node_pos_tbl_pdl = Array.make !nb_node (make_pos 0 0,no_info);
     node_neighbors = [];

     node_pos = make_pos x y;
     node_dest = make_pos x y;
     node_last_dir = 0; 
   }
    
let make_packet header src_node dest len =
  let dest_pos, dest_pos_date = 
    match header with
    | H_LER -> src_node.node_pos_tbl_ler.(dest) 
    | H_PDL _ -> src_node.node_pos_tbl_pdl.(dest) 
  in
  { packet_header = header;
    packet_src_id = src_node.node_id;
    packet_dest_id = dest;
    packet_dest_pos = dest_pos;
    packet_dest_pos_age = abs (src_node.node_date - dest_pos_date);
    packet_msg_len = len;
    packet_route = [];
    packet_anchors = [];
    packet_overhead = 0;
  }

let make_ler_packet =  make_packet H_LER 


let make_pdl_info node overhead =
  { pdl_id = node.node_id;
    pdl_pos = node.node_pos;
    pdl_pos_age = 0; 
    pdl_overhead = overhead;
  }

let make_pdl_info_forecast node overhead =
  let posx_forecast = 
    if node.node_pos.x < node.node_dest.x then
      min (node.node_pos.x + !pdl_forecast) !maxx
    else 
      if node.node_pos.x > node.node_dest.x then
	max (node.node_pos.x - !pdl_forecast) 0
      else
	node.node_pos.x
  in
  let posy_forecast = 
    if node.node_pos.y < node.node_dest.y then
      min (node.node_pos.y + !pdl_forecast) !maxy
    else 
      if node.node_pos.y > node.node_dest.y then
	max (node.node_pos.y - !pdl_forecast) 0
      else
	node.node_pos.y
  in
  { pdl_id = node.node_id;
    pdl_pos = make_pos posx_forecast posy_forecast;
    pdl_pos_age = - !pdl_forecast; 
    pdl_overhead = overhead;
  }

let make_pdl_packet src_node dest len =
  make_packet (H_PDL None) src_node dest len

let make_info_hello node =
  { hello_id = node.node_id; 
    hello_pos = node.node_pos;
    hello_node = node; 
  }


(* printing and string_of functions *)

let string_of_pos p =
  "("^(string_of_int p.x)^", "^(string_of_int p.y)^")"

let print_pos p = print_string (string_of_pos p)


let print_node n =
  begin
    print_string ("id : "^(string_of_int n.node_id));
    print_newline ();
    print_string ("date : "^(string_of_int n.node_date));
    print_newline ();
    print_string ("pos : "^(string_of_pos n.node_pos));
    print_newline ()
  end

let print_pos_tbl pos_tbl =
  for i = 0 to  !nb_node-1 do
    let (pos,date) = pos_tbl.(i) in
    print_string "\t";
    print_int i;
    print_string " : (";
    print_pos pos;
    print_string ", ";
    print_int date;
    print_string ")";
    print_newline();
  done

let string_of_pdl_info i =
  (string_of_int i.pdl_id)^"("^(string_of_int i.pdl_pos_age)^") = "^
  (string_of_pos i.pdl_pos)

let string_of_header = function
  | H_LER -> "LER"
  | H_PDL (Some i) -> "PDL : "^(string_of_pdl_info i)
  | H_PDL None -> "PDL : no info"

let print_packet p =
  print_string ("packet "^(string_of_header p.packet_header));
  print_newline();
  print_string ("\tsrc : "^(string_of_int p.packet_src_id));
  print_newline();
  print_string("\tdest : "^(string_of_int p.packet_dest_id)^"("^
	       (string_of_int p.packet_dest_pos_age)^") = "^
	       (string_of_pos p.packet_dest_pos));
  print_newline()

      
let print_hello_info i =
  print_string ("hello : "^
		(string_of_int i.hello_id)^" = "^
		(string_of_pos i.hello_pos));
  print_newline()

let print_neighbors l =
  print_string "[ ";
  List.iter
    (fun n -> print_string ((string_of_int n.hello_id)^"; "))
    l;
  print_string "]"

let string_of_kind = function
  | LER -> "LER"
  | PDL -> "PDL"
