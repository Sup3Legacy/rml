open Global
  

    
let get_neighbors n1 others =
  let filter n2 =
    let d2 = distance2 n1.node_posx n1.node_posy n2.hello_posx n2.hello_posy in
    d2 < dist_couv2 
  in
  List.filter filter others


let process node x_init y_init move draw =
  signal channel in
  let self = new_node x_init y_init in
  self.node_channel <- channel;
  loop
    self.node_age <- self.node_age + 1;
    move self;
    let info = make_info_hello self in
    emit draw info;
    let (i,j) as local_area, neighbor_areas = 
      Area.get_areas self.node_posx self.node_posy in
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)
(*
    if self.node_id = 1 then 
      begin
	print_string "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^";
	print_newline ();
	print_node self;
	List.iter 
	  (fun (i,j) ->
	    print_string ("node.neighbor_areas ("^(string_of_int i)^", "
		          ^(string_of_int j)^")");
	    print_newline())
	  (local_area::neighbor_areas);
	print_string "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv";
	print_newline();
      end;
*)
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)
    emit hello_array.(i).(j) info;
    pause;
    let all = 
      List.fold_left 
	(fun infos (i,j) -> 
	  List.rev_append (pre ?hello_array.(i).(j)) infos)
	[] (local_area::neighbor_areas)
    in
    let neighbors = get_neighbors self all in
    self.node_neighbors <- neighbors;
    Pos_tbl.update self.node_pos_tbl_ler neighbors self.node_age;
    Pos_tbl.update self.node_pos_tbl_pdl neighbors self.node_age;

    pause; 

    (* Routage *)
    if self.node_id = 1 then 
      let dest_id = (Random.int nb_node) in

      (* Routage LER *)
      let packet = make_packet LER self dest_id self in
      let _, _, age_dest = 
	self.node_pos_tbl_ler.(packet.packet_id_destination) 
      in
      if age_dest = no_info then
	match Routage.search_best_age LER 
	    self
	    packet.packet_id_destination max_int
	    self.node_neighbors
	with
	| None ->
	    (* routage fail *)
	    (print_string "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
	    print_newline())
	| Some (posx,posy,age) ->
	    packet.packet_posx_dest <- posx;
	    packet.packet_posy_dest <- posy;
	    packet.packet_age_pos_dest <- age;
	    self.node_pos_tbl_ler.(packet.packet_id_destination) <- 
	      (posx, posy, self.node_age-age);
(*
	    print_packet packet;
*)
	    Graphics.set_color Graphics.red;
	    Graphics.moveto self.node_posx self.node_posy;

	    Routage.routage LER self packet;

	    Graphics.set_color Graphics.black;
      else
	(Graphics.set_color Graphics.red;
	 Graphics.moveto self.node_posx self.node_posy;
(*
	 print_packet packet;
*)	 
	 Routage.routage LER self packet;
	 
	 Graphics.set_color Graphics.black;);

     (* Routage PDL *)
      let packet = make_packet PDL self dest_id self in
      let _, _, age_dest = 
	self.node_pos_tbl_pdl.(packet.packet_id_destination) 
      in
      if age_dest = no_info then
	match Routage.search_best_age PDL  
	    self
	    packet.packet_id_destination max_int
	    self.node_neighbors
	with
	| None ->
	    (* routage fail *)
	    (print_string "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!";
	    print_newline())
	| Some (posx,posy,age) ->
	    packet.packet_posx_dest <- posx;
	    packet.packet_posy_dest <- posy;
	    packet.packet_age_pos_dest <- age;
	    self.node_pos_tbl_pdl.(packet.packet_id_destination) <- 
	      (posx, posy, self.node_age-age);
(*
	    print_packet packet;
*)
	    Graphics.set_color Graphics.blue;
	    Graphics.moveto self.node_posx self.node_posy;

	    Routage.routage PDL self packet;

	    Graphics.set_color Graphics.black;
      else
	(Graphics.set_color Graphics.blue;
	 Graphics.moveto self.node_posx self.node_posy;
(*
	 print_packet packet;
*)	 
	 Routage.routage PDL self packet;
	 
	 Graphics.set_color Graphics.black;);

      pause;
 
  end


let draw_info n =
  if n.hello_id = 1 then
    (Graphics.set_color Graphics.red;
     Graphics.moveto n.hello_posx n.hello_posy;
     Graphics.draw_string (string_of_int n.hello_id);
     Graphics.set_color Graphics.black)
  else
(*
    Graphics.draw_circle n.hello_posx n.hello_posy 1
*)
    (Graphics.moveto n.hello_posx n.hello_posy;
     Graphics.draw_string (string_of_int n.hello_id))

let draw_neighborhood self =
  Graphics.set_color Graphics.green;
  List.iter
    (fun info ->
      Graphics.moveto self.hello_posx self.hello_posy;
      Graphics.lineto info.hello_posx info.hello_posy)
    self.hello_node.node_neighbors;
  Graphics.set_color Graphics.black


let process draw_simul draw =
  Graphics.open_graph (" "^(string_of_int maxx)^"x"^(string_of_int maxy));
  Graphics.auto_synchronize false;
  loop
    await draw (all) in 
    Graphics.clear_graph();
    List.iter draw_info all;
(*    List.iter draw_neighborhood all;*)
    Graphics.synchronize();
    pause;
    Graphics.synchronize();
(*
    for i = 1 to 20 do 
      pause;
    done
*)
  end

let rec process make_nodes n draw =
  if n > 0 then
    let x = Random.int maxx in
    let y = Random.int maxy in
    run (node x y Move.random_waypoint draw)
    ||
    run (make_nodes (n-1) draw)


let process main =
  Random.init 1;
  run Area.make_areas;
  signal draw in
  run (make_nodes nb_node draw)
  ||
  run (draw_simul draw)

 


    
