open Global
  
let get_new_id =
  let cpt = ref (-1) in
  fun () ->
    incr cpt;
    !cpt
      
let new_node x y =
  {  node_id = get_new_id();
     node_channel = Obj.magic();
     node_packets = [];
     node_age = 0;
     node_posx = x;
     node_posy = y;
     node_destx = x;
     node_desty = y;
     node_last_direction = 0; 
     node_pos_tbl = Array.make nb_node (0,0,min_int)
   }
    
let make_info_hello node =
  { info_id = node.node_id; 
    info_posx = node.node_posx;
    info_posy = node.node_posy; }
    
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)
    
let get_neighbors n1 others =
  let filter n2 =
    let d2 = distance2 n1.node_posx n1.node_posy n2.info_posx n2.info_posy in
    d2 < dist_couv2 
  in
  List.filter filter others
(*
let get_neighbors n1 others =
  let filter n2 =
    let d2 = distance2 n1.node_posx n1.node_posy n2.info_posx n2.info_posy in
    d2 < dist_couv2 
  in
  let l = List.filter filter others in
  print_string ("nb others = "^(string_of_int (List.length others)));
  print_newline();
  print_string ("nb neighbors = "^(string_of_int (List.length l)));
  print_newline();
  l
*)
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)

let random_dir () =
  match Random.int 8 with
  | 0 -> Up
  | 1 -> Up_Right
  | 2 -> Right
  | 3 -> Down_Right
  | 4 -> Down
  | 5 -> Down_Left
  | 6 -> Left
  | 7 -> Up_Left
  | _ -> failwith "Err: get_dir"
	
let random_move node = 
  let dir = random_dir () in
  let x = node.node_posx in
  let y = node.node_posy in
  match dir with
  | Up -> if y < maxy-1 then node.node_posy <- y + 1 
  | Down -> if 0 < y then node.node_posy <- y - 1 
  | Left -> if 0 < x then node.node_posx <- x - 1 
  | Right -> if x < maxx-1 then node.node_posx <- x + 1 
  | Up_Left -> 
      if 0 < x && y < maxy-1 then 
	(node.node_posy <- y + 1;
	 node.node_posx <- x - 1)
  | Up_Right -> 
      if x < maxx-1 && y < maxy-1 then 
	(node.node_posy <- y + 1;
	 node.node_posx <- x + 1)
  | Down_Left -> 
      if 0 < x && 0 < y then 
	(node.node_posy <- y - 1;
	 node.node_posx <- x - 1)
  | Down_Right -> 
      if x < maxx-1 && 0 < y then 
	(node.node_posy <- y - 1;
	 node.node_posx <- x + 1)

let random_waypoint n =
  if (n.node_posx = n.node_destx) & (n.node_posy = n.node_desty) then
    (n.node_posx <- Random.int maxx;
     n.node_posy <- Random.int maxy);
  
  if n.node_posx < n.node_destx then
    (n.node_posx <- n.node_posx + 1;
     if n.node_posy < n.node_desty then
       n.node_posy <- n.node_posy + 1
     else
      if n.node_posy > n.node_desty then
	n.node_posy <- n.node_posy - 1)
  else if n.node_posx > n.node_destx then
    (n.node_posx <- n.node_posx - 1;
     if n.node_posy < n.node_desty then
       n.node_posy <- n.node_posy + 1
     else
       if n.node_posy > n.node_desty then
	 n.node_posy <- n.node_posy - 1)


let process node x_init y_init move draw =
  signal channel in
  let self = new_node x_init y_init in
  self.node_channel <- channel;
  loop
    self.node_age <- self.node_age + 1;
    move self;
    let info = make_info_hello self in
    emit draw info;
    let (i,j) as local_area, neighbor_areas = 
      Area.get_areas self.node_posx self.node_posy in
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)
(*
    if self.node_id = 1 then
      begin
	print_string "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^";
	print_newline ();
	print_string ("id : "^(string_of_int self.node_id));
	print_newline ();
	print_string ("age : "^(string_of_int self.node_age));
	print_newline ();
	print_string ("posx : "^(string_of_int self.node_posx));
	print_newline ();
	print_string ("posy : "^(string_of_int self.node_posy));
	print_newline ();
	List.iter 
	  (fun (i,j) ->
	    print_string ("node.neighbor_areas ("^(string_of_int i)^", "
		          ^(string_of_int j)^")");
	    print_newline())
	  (local_area::neighbor_areas);
	for i = 0 to  nb_node-1 do
	  print_int i;
	  print_string " : (";
	  let (posx,posy,age) = self.node_pos_tbl.(i) in
	  print_int posx;
	  print_string ", ";
	  print_int posy;
	  print_string ", ";
	  print_int age;
	  print_string ")";
	  print_newline();
	done;
	print_string "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv";
	print_newline();
      end;
*)
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)
    emit hello_array.(i).(j) info;
    pause;
    let all = 
      List.fold_left 
	(fun infos (i,j) -> 
	  List.rev_append (pre ?hello_array.(i).(j)) infos)
	[] (local_area::neighbor_areas)
    in
    let neighbors = get_neighbors self all in
    Pos_tbl.update self.node_pos_tbl neighbors self.node_age;

(*    run routage*)

  end

let draw_info n =
  Graphics.draw_circle n.info_posx n.info_posy 1
(*
  Graphics.moveto n.info_posx n.info_posy;
  Graphics.draw_string (string_of_int n.info_id)
*)

let process draw_simul draw =
  Graphics.open_graph (" "^(string_of_int maxx)^"x"^(string_of_int maxy));
  loop
    await draw (all) in 
    Graphics.clear_graph();
    List.iter draw_info all;
    Graphics.synchronize();
    pause;
  end

let rec process make_nodes n draw =
  if n > 0 then
    let x = Random.int maxx in
    let y = Random.int maxy in
    run (node x y random_waypoint draw)
    ||
    run (make_nodes (n-1) draw)


let process main =
  run Area.make_areas;
  signal draw in
  run (make_nodes nb_node draw)
  ||
  run (draw_simul draw)

    
