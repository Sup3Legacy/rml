open Global
  
let get_id =
  let cpt = ref (-1) in
  fun () ->
    incr cpt;
    !cpt
      
let new_node x y =
  {  node_id = get_id();
     node_age = 0;
     node_posx = x;
     node_posy = y;
     node_last_direction = 0; 
     node_pos_tbl = Array.make nb_node (0,0,1000000)
   }
    
let make_info_hello node =
  { info_id = node.node_id; 
    info_posx = node.node_posx;
    info_posy = node.node_posy; }
    
    
let distance2 x1 y1 x2 y2 = 
  (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) 
    
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)
    
let get_neighbors n1 others =
  let filter n2 =
    let d2 = distance2 n1.node_posx n1.node_posy n2.info_posx n2.info_posy in
    d2 < dist_couv2 
  in
  List.filter filter others
(*
let get_neighbors n1 others =
  let filter n2 =
    let d2 = distance2 n1.node_posx n1.node_posy n2.info_posx n2.info_posy in
    d2 < dist_couv2 
  in
  let l = List.filter filter others in
  print_string ("nb others = "^(string_of_int (List.length others)));
  print_newline();
  print_string ("nb neighbors = "^(string_of_int (List.length l)));
  print_newline();
  l
*)
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)

let get_dir node =
  match Random.int 8 with
  | 0 -> Up
  | 1 -> Up_Right
  | 2 -> Right
  | 3 -> Down_Right
  | 4 -> Down
  | 5 -> Down_Left
  | 6 -> Left
  | 7 -> Up_Left
  | _ -> failwith "Err: get_dir"
	
let random_move node = 
  let dir = get_dir node in
  let x = node.node_posx in
  let y = node.node_posy in
  match dir with
  | Up -> if y < maxy-1 then node.node_posy <- y + 1 
  | Down -> if 0 < y then node.node_posy <- y - 1 
  | Left -> if 0 < x then node.node_posx <- x - 1 
  | Right -> if x < maxx-1 then node.node_posx <- x + 1 
  | Up_Left -> 
      if 0 < x && y < maxy-1 then 
	(node.node_posy <- y + 1;
	 node.node_posx <- x - 1)
  | Up_Right -> 
      if x < maxx-1 && y < maxy-1 then 
	(node.node_posy <- y + 1;
	 node.node_posx <- x + 1)
  | Down_Left -> 
      if 0 < x && 0 < y then 
	(node.node_posy <- y - 1;
	 node.node_posx <- x - 1)
  | Down_Right -> 
      if x < maxx-1 && 0 < y then 
	(node.node_posy <- y - 1;
	 node.node_posx <- x + 1)

let rec process bcast_hello info areas =
  match areas with
  | [] -> nothing
  | [(i,j)] -> 
      run (emit_hello_array.(i).(j) info) 
  | (i,j) :: areas ->
      run (emit_hello_array.(i).(j) info);
      run (bcast_hello info areas)
  

let process node x_init y_init move draw =
  signal aux in
  let self = new_node x_init y_init  in
  loop
    self.node_age <- self.node_age + 1;
    move self;
    let info = make_info_hello self in
    emit draw info;
    let (i,j) as local_area, neighbor_areas = 
      Area.get_areas self.node_posx self.node_posy in

(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)
(*
    print_string "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^";
    print_newline ();
    print_string ("id : "^(string_of_int self.node_id));
    print_newline ();
    print_string ("posx : "^(string_of_int self.node_posx));
    print_newline ();
    print_string ("posy : "^(string_of_int self.node_posy));
    print_newline ();
    List.iter 
      (fun (i,j) ->
	print_string ("node.neighbor_areas ("^(string_of_int i)^", "
		                             ^(string_of_int j)^")");
	print_newline())
      (local_area::neighbor_areas);
    print_string "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv";
    print_newline();
*)
(* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *)

    run (bcast_hello info (local_area::neighbor_areas));
    run (get_hello_array.(i).(j) aux);
    await immediate one aux(all) in
    let neighbors = get_neighbors self all in
    Pos_tbl.update self.node_pos_tbl neighbors self.node_age
  end

let draw_info n =
  Graphics.draw_circle n.info_posx n.info_posy 1


let process draw_simul draw =
  Graphics.open_graph (" "^(string_of_int maxx)^"x"^(string_of_int maxy));
  loop
    await draw (all) in 
    Graphics.clear_graph();
    List.iter draw_info all;
    Graphics.synchronize();
    pause;
  end

let rec process make_nodes n draw =
  if n > 0 then
    let x = Random.int maxx in
    let y = Random.int maxy in
    run (node x y random_move draw)
    ||
    run (make_nodes (n-1) draw)


let process main =
  run Area.make_areas;
  signal draw in
  run (make_nodes nb_node draw)
  ||
  run (draw_simul draw)

    
