(********************************************************************)
(* Constantes                                                       *)
(********************************************************************)
let maxx = 200
let maxy = 200
let sepy = 100

let neighbors = 4


type status_t =
  | Status_Top
  | Status_Right 
  | Status_Bottom
  | Status_Left
  | Status_Quiescent
  | Status_Wall
  | Status_None

type state_t = 
  | State_Basic
  | State_Collide
  | State_Barrier
  | State_Grow_gene
  | State_Ckl_gene
  | State_Invclk_gene
  | State_Translator
  | State_Sprout
  | State_Pre_waiter
  | State_Waiter
  | State_Stop
  | State_Erase


(********************************************************************)
(* Direction                                                        *)
(********************************************************************)
type local_t =
  | Local
  | Global

type dir_t =
  | Up
  | Down
  | Left
  | Right
 
let opposite dir =
  match dir with
  | Up -> Down
  | Down -> Up
  | Left -> Right
  | Right -> Left


(********************************************************************)
(* Info                                                             *)
(********************************************************************)

type info_t =
    { origine: dir_t;
      status: status_t;
      state: state_t;
      fired: int;
      new_status: status_t; 
      new_state: state_t; }

let make_info origine status state =
    { origine = origine;
      status = status;
      state = state;
      fired = 0;
      new_status = Status_None;
      new_state = State_Basic; }


(**************************************************************************)
(* neighborhood                                                           *)
(**************************************************************************)

type neighborhood_t = info_t list


(**************************************************************************)
(* image                                                                  *)
(**************************************************************************)
type image_t =
    {x: int;
     y: int;
     mutable color: Graphics.color; }

let new_image x y col =
  { x = x;
    y = y;
    color = col; }

let draw_image img = 
  Graphics.set_color img.color;
  Graphics.plot img.x img.y


let color_of_status s =
  match s with 
  | Status_Top -> Graphics.blue
  | Status_Right -> Graphics.blue
  | Status_Bottom -> Graphics.blue
  | Status_Left -> Graphics.blue
  | Status_Quiescent -> Graphics.red
  | Status_Wall -> Graphics.green
  | Status_None -> Graphics.black
 

(**************************************************************************)
(* cell                                                                   *)
(**************************************************************************)

type cell_t =
    { cell_x: int;
      cell_y: int;
      mutable cell_activation: (info_t -> process);
      mutable cell_emit_global: (process -> process);
      mutable cell_status: status_t;
      mutable cell_state: state_t;
      mutable cell_fired: int;
      mutable cell_image: image_t;
      mutable cell_neighborhood: neighborhood_t; }
      
let new_cell x y status state emit_gl =
  { cell_x = x;
    cell_y = y;
    cell_activation = (process info -> nothing); 
    cell_emit_global = emit_gl;
    cell_status = status;
    cell_state = state;
    cell_fired = 0;
    cell_image = new_image x y (color_of_status status);
    cell_neighborhood = []; }

let draw_cell c = 
  draw_image c.cell_image 


(**************************************************************************)
(* neighborhood functions                                                 *)
(**************************************************************************)
let border cell =
  cell.cell_y = sepy or cell.cell_y = sepy - 1

let is_up y =
  y >= sepy

let is_down y =
  y < sepy

let get_von_neumann_neighbors cell cell_array =
  let x = cell.cell_x in
  let y = cell.cell_y in
  let neighbors = ref [] in
  if 0 <= x-1 
  then neighbors := (Local, Left, cell_array.(x-1).(y)) :: !neighbors;
  if x+1 < maxx 
  then neighbors := (Local, Right, cell_array.(x+1).(y)) :: !neighbors;
  if is_up y
  then
    if is_up (y-1) 
    then neighbors := (Local, Down, cell_array.(x).(y-1)) :: !neighbors
    else neighbors := (Global, Down, cell_array.(x).(y-1)) :: !neighbors
  else
    if 0 <= y-1 
    then neighbors := (Local, Down, cell_array.(x).(y-1)) :: !neighbors;
  if is_down y
  then
    if is_down (y+1)
    then neighbors := (Local, Up, cell_array.(x).(y+1)) :: !neighbors
    else neighbors := (Global, Up, cell_array.(x).(y+1)) :: !neighbors
  else
    if y+1 < maxy 
    then neighbors := (Local, Up, cell_array.(x).(y+1)) :: !neighbors;
  !neighbors


let get_neighbors = get_von_neumann_neighbors


(**************************************************************************)
(* cell process                                                           *)
(**************************************************************************)

let rec process activate_neighborhood self neighbors loc =
  match neighbors with
  | [] -> nothing
  | (Local, dir, Some cell) :: neighbors ->
      begin
	if loc = Local 
	then
	  let info = 
	    make_info (opposite dir) self.cell_status self.cell_state 
	  in
	  run (cell.cell_activation info);
      end;
      run (activate_neighborhood self neighbors loc)

  | (Global, dir, Some cell) :: neighbors ->
      begin
      if loc = Global
      then
	let info = 
	  make_info (opposite dir) self.cell_status self.cell_state 
	in
	run (cell.cell_emit_global (cell.cell_activation info));
      end;
      run (activate_neighborhood self neighbors loc)

  | (loc, dir, None) :: neighbors ->
      print_string "Warning: activation of a dead cell";
      print_newline();
      run (activate_neighborhood self neighbors loc)



let process cell self cell_behavior cell_array synchro =
  signal activation in
  self.cell_activation <- 
    (process info -> 
      emit activation info);
  draw_cell self;
  pause;
  loop
    if border self 
    then 
      run 
	(activate_neighborhood self (get_neighbors self cell_array) Global);
    await immediate synchro;
    if self.cell_status <> Status_Quiescent 
    then 
      run (activate_neighborhood self (get_neighbors self cell_array) Local)
    else 
      await immediate activation;
    let activation <neighbors> in
    self.cell_neighborhood <- neighbors;
    cell_behavior self;
    draw_cell self;
  end


(**************************************************************************)
(* synchronizer                                                           *)
(**************************************************************************)

let process synchronizer start others synchro term =
  pause;
  emit term;
  loop
    await immediate start;
    let others <active_neighbors> in
    emit synchro;
    run active_neighbors;
    pause;
    emit term
  end
  

(**************************************************************************)
(* cell behaviors                                                         *)
(**************************************************************************)

let fredkin cell = 
  let cpt = ref 0 in
  List.iter 
    (fun info -> if info.status <> Status_Quiescent then incr cpt)
    cell.cell_neighborhood;
  cell.cell_status <- 
    if (!cpt mod 2) = 1 then Status_Wall else Status_Quiescent; 
  cell.cell_image.color <- 
    if cell.cell_status = Status_Quiescent 
    then Graphics.red 
    else Graphics.green


(**************************************************************************)
(* cellular automaton                                                     *)
(**************************************************************************)
let cellular_automaton_create () =
  Array.make_matrix maxx maxy None


let rec cellular_automaton_init 
    cell_array i j emit_up_to_down emit_down_to_up =
  if i < maxx then
    if j < maxy then
      let status = 
(*	if i = 0 or i = maxx/2 or i = (maxx-1) or j = 0 or j = (maxy-1)  *)
(*	if i = maxx/2 *) 
	if i = maxx/2 && j = maxy/2  
	then Status_Wall 
	else Status_Quiescent
      in
      let emit_to_other =
	if is_down j then
	  emit_down_to_up
	else
	  emit_up_to_down
      in
      cell_array.(i).(j) <- 
	Some (new_cell i j status State_Basic emit_to_other);
      cellular_automaton_init 
	cell_array i (j+1) emit_up_to_down emit_down_to_up
    else
      cellular_automaton_init 
	cell_array (i+1) 0 emit_up_to_down emit_down_to_up
  else
    ()

let opt_val x =
  match x with
  | Some v -> v
  | None -> failwith "Pb : cellular_automaton_start"

let rec process cellular_automaton_start cell_array i j 
    synchro_up synchro_down =
  if i < maxx then
    if j < maxy then
      ((
       if is_down j then
	 run 
	   (cell (opt_val cell_array.(i).(j)) fredkin cell_array synchro_down)
       else
	 run (cell (opt_val cell_array.(i).(j)) fredkin cell_array synchro_up))
       ||
       run 
	 (cellular_automaton_start cell_array i (j+1) synchro_up synchro_down))
    else
      run (cellular_automaton_start cell_array (i+1) 0 synchro_up synchro_down)
  else
    nothing
      

(**************************************************************************)
(* main                                                                   *)
(**************************************************************************)
let process main =
  let cell_array = cellular_automaton_create() in
  signal start_up, start_down in
  signal synchro_up, synchro_down in
  signal  up_to_down, down_to_up 
  default process -> nothing
  gather process p1 p2 -> run p1 || run p2
  in
  let process emit_up_to_down p = 
    emit up_to_down p 
  in
  let process emit_down_to_up p = 
    emit down_to_up p 
  in
  cellular_automaton_init cell_array 0 0 emit_up_to_down emit_down_to_up; 
  Graphics.open_graph (" "^(string_of_int maxx)^"x"^(string_of_int maxy));
  Graphics.auto_synchronize false;
  run (synchronizer 
	 start_down 
	 up_to_down
	 synchro_down
	 start_up)
  ||
  run (synchronizer 
	 start_up
         down_to_up
	 synchro_up
	 start_down)
  ||
  run (cellular_automaton_start cell_array 0 0 synchro_up synchro_down)
  ||
  loop 
    Graphics.synchronize (); 
    pause;
  end


